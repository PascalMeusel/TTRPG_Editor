================================================================================
PROJECT DIRECTORY STRUCTURE
================================================================================

📂 ./
    📄 .gitignore
    📄 README.md
    📄 TTRPG_Editor.spec
    📄 app_controller.py
    📄 build.sh
    📄 campaign_model.py
    📄 custom_dialogs.py
    📄 database.py
    📄 main.py
    📄 main_menu_view.py
    📄 project_snapshot.txt
    📄 projectpacker.py
    📄 requirements.txt
    📄 ui_extensions.py
    📄 utils.py
    📂 music/
        📄 music_controller.py
        📄 music_model.py
        📄 music_view.py
    📂 assets/
        📂 music/
            📄 motivation-motivational-background-music-388288.mp3
        📂 landmarks/
    📂 map/
        📄 map_controller.py
        📄 map_model.py
        📄 map_view.py
        📂 map_generation/
            📄 map_generation_controller.py
            📄 map_generation_model.py
            📄 map_generation_view.py
    📂 data/
        📂 campaigns/
            📂 assd/
                📄 campaign.json
                📂 npcs/
                📂 characters/
                📂 maps/
            📂 PascalTest12/
                📄 campaign.json
                📂 npcs/
                📂 characters/
                    📄 peter.json
                📂 maps/
                    📄 generated_dungeon.png
            📂 HelloWorld/
                📄 campaign.db
                📄 campaign.json
                📄 items.json
                📄 quests.json
                📂 npcs/
                    📄 423.json
                    📄 bolg_skullcrusher.json
                    📄 durin_ironhide.json
                    📄 jax_kowalski.json
                    📄 marie.json
                    📄 peter.json
                    📄 ronan_swiftwater.json
                    📄 seraphina_moonwhisper.json
                    📄 test123.json
                📂 characters/
                    📄 das.json
                📂 maps/
                    📄 generic.json
                    📄 generic.png
                    📄 hi.json
                    📄 hi.png
                    📄 new_generated_dsad.json
                    📄 new_generated_dsad.png
                📂 data/
                    📄 items.json
            📂 Test/
                📄 campaign.json
                📂 npcs/
                📂 characters/
                📂 maps/
                    📄 generated_dungeon.json
                    📄 generated_dungeon.png
            📂 PascalsCampaign/
                📄 campaign.json
                📂 npcs/
                📂 characters/
                📂 maps/
        📂 rule_sets/
            📄 cyberpunk_red.json
            📄 d&d_5e.json
    📂 quest/
        📄 quest_controller.py
        📄 quest_model.py
        📄 quest_view.py
    📂 dist/
    📂 combat/
        📄 combat_controller.py
        📄 combat_model.py
        📄 combat_view.py
    📂 build/
        📂 TTRPG_Editor/
    📂 npc/
        📄 npc_controller.py
        📄 npc_generator_model.py
        📄 npc_model.py
        📄 npc_view.py
    📂 rules/
        📄 rules_controller.py
        📄 rules_editor_window.py
        📄 rules_model.py
    📂 character/
        📄 character_controller.py
        📄 character_model.py
        📄 character_view.py
    📂 output/
        📂 windows/
        📂 linux/
    📂 item/
        📄 item_controller.py
        📄 item_model.py
        📄 item_view.py


================================================================================
PYTHON FILE CONTENTS
================================================================================

================================================================================
--- FILE: app_controller.py ---
================================================================================

import customtkinter as ctk
import tkinter as tk
import os
import time

from rules.rules_controller import RulesController
from character.character_controller import CharacterController
from npc.npc_controller import NpcController
from combat.combat_controller import CombatController
from music.music_controller import MusicController
from map.map_controller import MapController
from item.item_controller import ItemController
from quest.quest_controller import QuestController
from item.item_model import ItemModel
from quest.quest_model import QuestModel
from character.character_model import CharacterModel
from npc.npc_model import NpcModel

from campaign_model import CampaignModel
from main_menu_view import MainMenuView, NewCampaignDialog
from custom_dialogs import MessageBox
from rules.rules_editor_window import RulesEditorWindow
from rules.rules_model import RulesModel

class AppController:
    def __init__(self, root):
        self.root = root
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)
        self.campaign_model = CampaignModel()
        self.current_campaign_path = None
        self.editor_frame = None
        self.unsaved_changes = False
        self.ruleset_data = None
        self.left_pane_pinned = False
        self.right_pane_pinned = False
        self.last_active_pane = "right"
        self.is_map_fullscreen = False
        self.data_cache = {}
        
        # --- REFACTOR: Use a single, flat cache for all features ---
        self.feature_cache = {}
        self.left_pane_feature_name = "Characters"
        self.right_pane_feature_name = "Items"
        self.pre_map_left_pane_feature = "Characters"
        self.pre_map_right_pane_feature = "Items"

        self.main_menu_view = MainMenuView(root, self)
        self.show_main_menu()

    def get_cached_data(self, key):
        return self.data_cache.get(key)

    def set_cached_data(self, key, data):
        self.data_cache[key] = data

    def clear_data_cache(self):
        self.data_cache.clear()

    def run(self):
        self.root.mainloop()

    def show_main_menu(self):
        # --- FIX: Immediately hide the editor and show the menu for responsiveness ---
        if self.editor_frame:
            self.editor_frame.destroy()
        
        self.main_menu_view.pack(fill="both", expand=True)
        self.main_menu_view.tkraise()
        
        # --- FIX: Schedule the heavy cleanup to run after the UI has updated ---
        # This prevents the application from freezing while destroying all the editor widgets.
        self.root.after(100, self._cleanup_editor_session)

    def _cleanup_editor_session(self):
        if self.editor_frame:
            self.editor_frame.destroy()
        self.editor_frame = None
        self.ruleset_data = None
        self.current_campaign_path = None
        self.left_pane_pinned = False
        self.right_pane_pinned = False
        # --- REFACTOR: Reset to a flat dictionary ---
        self.feature_cache = {}
        self.clear_data_cache()
        self.is_map_fullscreen = False

    def _show_editor(self):
        self.main_menu_view.pack_forget()
        
        if self.editor_frame is None:
            self.unsaved_changes = False
            self.editor_frame = ctk.CTkFrame(self.root, fg_color="transparent")
            
            # --- Build the basic UI shell first ---
            self.editor_frame.grid_columnconfigure(1, weight=1)
            self.editor_frame.grid_rowconfigure(1, weight=1)
            
            # 1. Header
            header_frame = ctk.CTkFrame(self.editor_frame, corner_radius=0, height=150, border_width=1, border_color="gray25")
            header_frame.grid(row=0, column=0, columnspan=2, sticky="ew")
            header_left = ctk.CTkFrame(header_frame, fg_color="transparent")
            header_left.pack(side="left", padx=20, pady=10)
            self.header_label = ctk.CTkLabel(header_left, text="Loading Campaign...", font=ctk.CTkFont(size=18))
            self.header_label.pack()
            
            # 2. Sidebar (placeholder)
            ctk.CTkFrame(self.editor_frame, width=200, corner_radius=0, border_width=1, border_color="gray25").grid(row=1, column=0, sticky="nsw")
            
            # 3. Main Content Area (placeholder)
            ctk.CTkFrame(self.editor_frame, fg_color="transparent").grid(row=1, column=1, sticky="nsew")
            
            # --- Show the shell immediately ---
            self.editor_frame.pack(fill="both", expand=True)
            self.editor_frame.tkraise()
            
            # --- Defer the heavy loading to a new method ---
            self.root.after(50, self._finish_editor_setup)

    def _finish_editor_setup(self):
        """
        Performs the heavy lifting of loading data and creating feature controllers
        after the main editor UI shell is already visible.
        """
        print("Starting deferred editor setup")
        startTime = time.time()

        # --- Get references to the placeholder frames created in _show_editor ---
        header_frame = self.editor_frame.winfo_children()[0]
        sidebar_frame = self.editor_frame.winfo_children()[1]
        self.main_content_area = self.editor_frame.winfo_children()[2]
        
        # --- Populate the main content area ---
        self.main_content_area.grid_columnconfigure(0, weight=1)
        self.main_content_area.grid_rowconfigure(0, weight=1)
        self.paned_window = tk.PanedWindow(self.main_content_area, orient=tk.HORIZONTAL, sashwidth=10, bg="#2B2B2B", bd=0, relief="raised", sashrelief=tk.RAISED)
        self.paned_window.grid(row=0, column=0, sticky="nsew")
        self.left_pane_wrapper = ctk.CTkFrame(self.paned_window, fg_color="gray14", corner_radius=0, border_width=2, border_color="gray25")
        self.left_pane_wrapper.grid_columnconfigure(0, weight=1)
        self.left_pane_wrapper.grid_rowconfigure(1, weight=1)
        self.paned_window.add(self.left_pane_wrapper, minsize=400)
        left_header = ctk.CTkFrame(self.left_pane_wrapper, fg_color="gray20", corner_radius=0, height=35)
        left_header.grid(row=0, column=0, sticky="ew")
        self.left_pane_label = ctk.CTkLabel(left_header, text="Characters", anchor="w")
        self.left_pane_label.pack(side="left", padx=10, pady=5)
        self.left_pin_button = ctk.CTkButton(left_header, text="📌", width=30, fg_color="transparent", command=lambda: self.toggle_pin("left"))
        self.left_pin_button.pack(side="right", padx=5, pady=5)
        self.left_pane_frame = ctk.CTkFrame(self.left_pane_wrapper, fg_color="transparent")
        self.left_pane_frame.grid(row=1, column=0, sticky="nsew")
        self.left_pane_frame.grid_rowconfigure(0, weight=1)
        self.left_pane_frame.grid_columnconfigure(0, weight=1)
        self.right_pane_wrapper = ctk.CTkFrame(self.paned_window, fg_color="gray14", corner_radius=0, border_width=2, border_color="gray25")
        self.right_pane_wrapper.grid_columnconfigure(0, weight=1)
        self.right_pane_wrapper.grid_rowconfigure(1, weight=1)
        self.paned_window.add(self.right_pane_wrapper, minsize=400)
        right_header = ctk.CTkFrame(self.right_pane_wrapper, fg_color="gray20", corner_radius=0, height=35)
        right_header.grid(row=0, column=0, sticky="ew")
        self.right_pane_label = ctk.CTkLabel(right_header, text="Items", anchor="w")
        self.right_pane_label.pack(side="left", padx=10, pady=5)
        self.right_pin_button = ctk.CTkButton(right_header, text="📌", width=30, fg_color="transparent", command=lambda: self.toggle_pin("right"))
        self.right_pin_button.pack(side="right", padx=5, pady=5)
        self.right_pane_frame = ctk.CTkFrame(self.right_pane_wrapper, fg_color="transparent")
        self.right_pane_frame.grid(row=1, column=0, sticky="nsew")
        self.right_pane_frame.grid_rowconfigure(0, weight=1)
        self.right_pane_frame.grid_columnconfigure(0, weight=1)
        self.fullscreen_map_frame = ctk.CTkFrame(self.main_content_area, fg_color="transparent")
        self.fullscreen_map_frame.grid_rowconfigure(0, weight=1)
        self.fullscreen_map_frame.grid_columnconfigure(0, weight=1)

        # --- Populate the header and sidebar ---
        header_right = ctk.CTkFrame(header_frame, fg_color="transparent")
        header_right.pack(side="right", padx=10, pady=5)
        self.music_controller = MusicController(self, header_right)
        
        sidebar_frame.grid_rowconfigure(0, weight=1)
        sidebar_nav_frame = ctk.CTkFrame(sidebar_frame, fg_color="transparent")
        sidebar_nav_frame.grid(row=0, column=0, sticky="new", padx=5, pady=5)
        
        # --- REMOVED EAGER LOADING ---
        # Features are now created on-demand when first clicked.

        # --- Sidebar buttons are still created upfront ---
        for name in ["Characters", "NPCs", "Items", "Quests", "Combat", "Map Editor"]:
            button = ctk.CTkButton(sidebar_nav_frame, text=name, corner_radius=0, fg_color="transparent", height=40, anchor="w")
            button.pack(fill="x")
            button.bind("<Button-1>", lambda event, n=name: self.load_feature(n))
            button.bind("<Button-3>", lambda event, n=name: self._show_context_menu(event, n))
        ctk.CTkButton(sidebar_frame, text="< Back to Main Menu", command=self.confirm_exit_to_main_menu, fg_color="transparent", border_width=1, border_color="gray50", height=40).grid(row=1, column=0, sticky="sew", padx=10, pady=10)
        
        # --- DATA LOADING (now deferred) ---
        ruleset_name = self.campaign_model.get_campaign_ruleset(os.path.basename(self.current_campaign_path))
        if ruleset_name:
            rules_model = RulesModel()
            self.ruleset_data = rules_model.load_rule_set(ruleset_name)
            if self.ruleset_data:
                campaign_name = os.path.basename(self.current_campaign_path)
                self.header_label.configure(text=f"{campaign_name}  |  Ruleset: {ruleset_name}")
                # --- The heavy _load_all_data_to_cache() is REMOVED from here ---
            else:
                MessageBox.showerror("Error", f"Failed to load required ruleset '{ruleset_name}'.", self.root)
                self.show_main_menu()
                return
        
        self.root.after(100, lambda: self.paned_window.sash_place(0, self.paned_window.winfo_width() // 2, 0))
        # Display the initial default panes. This will trigger their creation.
        self._redisplay_panes(None, None)
        
        print("Deferred rendering done in ")
        print(time.time() - startTime)
        print(" seconds")

    def _create_feature_by_name(self, feature_name, parent_frame):
        """Helper method to instantiate a controller based on its name."""
        content = None
        if feature_name == "Characters": content = CharacterController(self, parent_frame, self.current_campaign_path)
        elif feature_name == "NPCs": content = NpcController(self, parent_frame, self.current_campaign_path)
        elif feature_name == "Items": content = ItemController(self, parent_frame, self.current_campaign_path)
        elif feature_name == "Quests": content = QuestController(self, parent_frame, self.current_campaign_path)
        elif feature_name == "Combat": content = CombatController(self, parent_frame, self.current_campaign_path)
        elif feature_name == "Map Editor": content = MapController(self, parent_frame, self.current_campaign_path)
        return content

    def _get_or_create_feature(self, feature_name):
        """
        --- NEW: Central method for lazy loading features. ---
        Gets a feature from the cache or creates it if it doesn't exist.
        """
        if feature_name not in self.feature_cache:
            print(f"Lazy loading feature: {feature_name}")
            # Create the feature's frame inside the main content area
            feature_frame = ctk.CTkFrame(self.main_content_area, fg_color="transparent")
            content = self._create_feature_by_name(feature_name, feature_frame)
            
            # Store the controller and its frame in the cache
            self.feature_cache[feature_name] = {'controller': content, 'frame': feature_frame}
            
            # Inform the new controller about the ruleset
            if self.ruleset_data and hasattr(content, 'handle_rule_set_load'):
                content.handle_rule_set_load(self.ruleset_data)
        
        return self.feature_cache[feature_name]

    def _reload_character_cache(self):
        """Helper method to reload only the character models into the cache."""
        if not self.ruleset_data: return
        char_cache_key = f"characters_models_{self.ruleset_data['name']}"
        # --- OPTIMIZED: This call is now a single, fast DB query ---
        char_models = CharacterModel.get_all_for_ruleset(self.current_campaign_path, self.ruleset_data['name'])
        self.set_cached_data(char_cache_key, sorted(char_models, key=lambda m: m.name))

    def _reload_npc_cache(self):
        """Helper method to reload only the NPC models into the cache."""
        if not self.ruleset_data: return
        npc_cache_key = f"npcs_models_{self.ruleset_data['name']}"
        # --- OPTIMIZED: This call is now a single, fast DB query ---
        npc_models = NpcModel.get_all_for_ruleset(self.current_campaign_path, self.ruleset_data['name'])
        self.set_cached_data(npc_cache_key, sorted(npc_models, key=lambda m: m.name))

    def toggle_pin(self, pane):
        if pane == "left":
            self.left_pane_pinned = not self.left_pane_pinned
            self.left_pin_button.configure(fg_color="#3B8ED0" if self.left_pane_pinned else "transparent")
            if self.left_pane_pinned and self.right_pane_pinned:
                self.right_pane_pinned = False
                self.right_pin_button.configure(fg_color="transparent")
        else:
            self.right_pane_pinned = not self.right_pane_pinned
            self.right_pin_button.configure(fg_color="#3B8ED0" if self.right_pane_pinned else "transparent")
            if self.right_pane_pinned and self.left_pane_pinned:
                self.left_pane_pinned = False
                self.left_pin_button.configure(fg_color="transparent")

    def load_feature(self, feature_name):
        if self.is_map_fullscreen and feature_name != "Map Editor":
            self._exit_fullscreen_map_mode()
            # Fall through to load the feature after exiting fullscreen

        if self.left_pane_pinned and self.right_pane_pinned:
            MessageBox.showinfo("Info", "Both panes are pinned. Unpin one to load a new feature.", self.root)
            return

        target_pane = None
        if self.left_pane_pinned:
            target_pane = "right"
        elif self.right_pane_pinned:
            target_pane = "left"
        else:
            # If feature is already visible, target its pane to bring it to focus,
            # otherwise target the non-active pane.
            if feature_name == self.left_pane_feature_name:
                target_pane = "left"
            elif feature_name == self.right_pane_feature_name:
                target_pane = "right"
            elif self.last_active_pane == "right":
                target_pane = "left"
            else:
                target_pane = "right"
        
        self.load_feature_into_pane(feature_name, target_pane)

    def _show_context_menu(self, event, feature_name):
        context_menu = tk.Menu(self.root, tearoff=0, bg="#2B2B2B", fg="white", activebackground="#3B8ED0")
        context_menu.add_command(label=f"Open '{feature_name}' in Left Pane", command=lambda: self.load_feature_into_pane(feature_name, "left"))
        context_menu.add_command(label=f"Open '{feature_name}' in Right Pane", command=lambda: self.load_feature_into_pane(feature_name, "right"))
        context_menu.tk_popup(event.x_root, event.y_root)

    def load_feature_into_pane(self, feature_name, pane_target):
        if feature_name == "Map Editor":
            if not self.is_map_fullscreen: self._enter_fullscreen_map_mode()
            return
        
        if self.is_map_fullscreen:
            self._exit_fullscreen_map_mode()
            # After exiting, we need to ensure the correct panes are shown.
            # The load_feature call below will handle this

        prev_left = self.left_pane_feature_name
        prev_right = self.right_pane_feature_name

        new_left, new_right = prev_left, prev_right

        if pane_target == "left":
            if feature_name == prev_right: # Swap
                new_left, new_right = prev_right, prev_left
            else: # Assign
                new_left = feature_name
        else: # pane_target == "right"
            if feature_name == prev_left: # Swap
                new_left, new_right = prev_right, prev_left
            else: # Assign
                new_right = feature_name
        
        if (new_left, new_right) != (prev_left, prev_right):
            self.left_pane_feature_name = new_left
            self.right_pane_feature_name = new_right
            self._redisplay_panes(prev_left, prev_right)

        self.last_active_pane = pane_target

    def _redisplay_panes(self, prev_left_feature=None, prev_right_feature=None):
        """Hides old containers and shows new ones, only if changed."""
        new_left = self.left_pane_feature_name
        new_right = self.right_pane_feature_name

        # Only update the left pane if the feature has changed
        if prev_left_feature != new_left:
            if prev_left_feature and prev_left_feature in self.feature_cache:
                self.feature_cache[prev_left_feature]['frame'].grid_forget()
            
            # --- LAZY LOAD: Create the feature if it doesn't exist ---
            feature = self._get_or_create_feature(new_left)
            feature['frame'].grid(in_=self.left_pane_frame, row=0, column=0, sticky="nsew")
            self.left_pane_label.configure(text=new_left)

        # Only update the right pane if the feature has changed
        if prev_right_feature != new_right:
            if prev_right_feature and prev_right_feature in self.feature_cache:
                self.feature_cache[prev_right_feature]['frame'].grid_forget()

            # --- LAZY LOAD: Create the feature if it doesn't exist ---
            feature = self._get_or_create_feature(new_right)
            feature['frame'].grid(in_=self.right_pane_frame, row=0, column=0, sticky="nsew")
            self.right_pane_label.configure(text=new_right)

    def _enter_fullscreen_map_mode(self):
        self.pre_map_left_pane_feature = self.left_pane_feature_name
        self.pre_map_right_pane_feature = self.right_pane_feature_name
        
        # Un-parent the current pane frames
        if self.left_pane_feature_name in self.feature_cache:
            self.feature_cache[self.left_pane_feature_name]['frame'].grid_forget()
        if self.right_pane_feature_name in self.feature_cache:
            self.feature_cache[self.right_pane_feature_name]['frame'].grid_forget()

        self.paned_window.grid_forget()
        self.fullscreen_map_frame.grid(row=0, column=0, sticky="nsew")
        self.is_map_fullscreen = True
        
        # Move the map frame into the fullscreen container
        map_feature = self._get_or_create_feature("Map Editor")
        map_feature['frame'].grid(in_=self.fullscreen_map_frame, row=0, column=0, sticky="nsew")

    def _exit_fullscreen_map_mode(self):
        # Un-parent the map frame
        if "Map Editor" in self.feature_cache:
            self.feature_cache["Map Editor"]['frame'].grid_forget()

        self.fullscreen_map_frame.grid_forget()
        self.paned_window.grid(row=0, column=0, sticky="nsew")
        self.is_map_fullscreen = False
        
        # Restore the panes to their pre-fullscreen state
        prev_left = self.left_pane_feature_name
        prev_right = self.right_pane_feature_name
        self.left_pane_feature_name = self.pre_map_left_pane_feature
        self.right_pane_feature_name = self.pre_map_right_pane_feature
        self._redisplay_panes(prev_left, prev_right)

    def get_loaded_controller(self, controller_class):
        feature_map = {
            CharacterController: "Characters", NpcController: "NPCs",
            ItemController: "Items", QuestController: "Quests",
            CombatController: "Combat", MapController: "Map Editor"
        }
        feature_name = feature_map.get(controller_class)
        if not feature_name: return None

        # --- REFACTOR: Use the lazy-loading getter ---
        # This ensures that if a controller needs another one that hasn't been
        # opened by the user yet, it gets created on the fly.
        feature = self._get_or_create_feature(feature_name)
        return feature['controller']

    def set_dirty_flag(self, is_dirty=True):
        self.unsaved_changes = is_dirty

    def confirm_exit_to_main_menu(self):
        if not self.unsaved_changes:
            self.show_main_menu()
            return

        response = MessageBox.askyesnocancel("Unsaved Changes", "You have unsaved changes. Save them before exiting?", parent=self.root)
        
        if response is True: # User wants to save
            MessageBox.showinfo("Save Manually", "Please use the 'Save Changes' buttons in the relevant panes to save your work.", parent=self.root)
            # Do not exit, allow user to save.
        elif response is False: # User wants to exit without saving
            self.unsaved_changes = False
            self.show_main_menu()
        # if response is None (Cancel), do nothing.
            
    def new_game_flow(self):
        rules_model = RulesModel()
        rulesets = rules_model.get_all_rule_sets()
        if not rulesets:
            MessageBox.showerror("Error", "No rule sets found...", self.root)
            return
        dialog = NewCampaignDialog(parent=self.root, rulesets=rulesets)
        result = dialog.get_input()
        if not result: return
        campaign_name, ruleset_name = result
        self._cleanup_editor_session()
        path = self.campaign_model.create_campaign(campaign_name, ruleset_name)
        if path:
            self.current_campaign_path = path
            self._show_editor()
        else:
            MessageBox.showerror("Error", f"A campaign named '{campaign_name}' already exists.", self.root)

    def load_game_flow(self, campaign_name):
        if not campaign_name:
            MessageBox.showerror("Error", "Please select a campaign to load.", self.root)
            return
        
        # Since we are loading, we assume we are coming from the main menu.
        # A full cleanup ensures no old state persists.
        self._cleanup_editor_session()
        
        self.current_campaign_path = os.path.join(self.campaign_model.base_dir, campaign_name)
        
        # --- FIX: Ensure database exists for backward compatibility ---
        db_path = os.path.join(self.current_campaign_path, 'campaign.db')
        if not os.path.exists(db_path):
            print(f"Database not found for '{campaign_name}'. Initializing for compatibility.")
            db = Database(self.current_campaign_path)
            db.initialize_schema()
            # NOTE: This will allow old campaigns to load without crashing.
            # Data from old JSON files will not be migrated automatically.

        if os.path.exists(self.current_campaign_path):
            self._show_editor()
        else:
            MessageBox.showerror("Error", f"Could not find campaign data for '{campaign_name}'.", self.root)
            # If loading fails, ensure the path is also cleared.
            self.current_campaign_path = None

    def show_ruleset_creator_standalone(self):
        ruleset_window = RulesEditorWindow(self.root)
        standalone_rules_controller = RulesController(self)
        standalone_rules_controller.set_view(ruleset_window)
        ruleset_window.set_controller(standalone_rules_controller)

    def show_placeholder_message(self):
        MessageBox.showinfo("Not Implemented", "This feature is not yet available.", self.root)

    def exit_app(self):
        self.root.quit()
        self.root.destroy()
        
    def on_character_or_npc_list_changed(self):
        """Reloads char/npc cache and tells all controllers to refresh their views."""
        self._reload_character_cache()
        self._reload_npc_cache()

        # Only update controllers that have already been loaded
        for feature in self.feature_cache.values():
            content = feature['controller']
            if hasattr(content, 'update_combatant_lists'): content.update_combatant_lists()
            if hasattr(content, 'update_character_sheet_list'): content.update_character_sheet_list()
            if hasattr(content, 'update_npc_management_list'): content.update_npc_management_list()
            if hasattr(content, 'update_npc_sheet_list'): content.update_npc_sheet_list()
            if hasattr(content, 'update_token_placer_list'): content.update_token_placer_list()

    def refresh_char_npc_sheet_if_loaded(self):
        # This needs to find the active character/npc controller
        char_controller = self.get_loaded_controller(CharacterController)
        if char_controller and char_controller.current_character:
            char_controller.load_character_to_sheet(refresh=True)
        
        npc_controller = self.get_loaded_controller(NpcController)
        if npc_controller and npc_controller.current_npc:
            npc_controller.load_npc_to_sheet(refresh=True)

================================================================================
--- FILE: campaign_model.py ---
================================================================================

import os
import json
from utils import resource_path # Import the helper
from database import Database

class CampaignModel:
    """Manages the creation and listing of campaign save files."""
    def __init__(self, base_dir_name="data/campaigns"):
        # Use the helper to get the correct base directory
        self.base_dir = resource_path(base_dir_name)
        if not os.path.exists(self.base_dir):
            os.makedirs(self.base_dir)

    def list_campaigns(self):
        """Returns a list of all existing campaign names."""
        return sorted([d for d in os.listdir(self.base_dir) if os.path.isdir(os.path.join(self.base_dir, d))])

    def create_campaign(self, name, ruleset_name):
        """Creates the necessary directory structure for a new campaign."""
        campaign_path = os.path.join(self.base_dir, name)
        if os.path.exists(campaign_path):
            return None # Campaign already exists

        # Create all necessary subdirectories
        os.makedirs(os.path.join(campaign_path, "characters"))
        os.makedirs(os.path.join(campaign_path, "npcs"))
        os.makedirs(os.path.join(campaign_path, "maps"))

        # --- NEW: Initialize the database for the new campaign ---
        db = Database(campaign_path)
        db.initialize_schema()

        # Create a metadata file to store the chosen ruleset
        metadata = {"ruleset": ruleset_name}
        with open(os.path.join(campaign_path, "campaign.json"), 'w') as f:
            json.dump(metadata, f, indent=4)
        
        return campaign_path

    def get_campaign_ruleset(self, name):
        """Reads the metadata file to find which ruleset a campaign uses."""
        metadata_path = os.path.join(self.base_dir, name, "campaign.json")
        if not os.path.exists(metadata_path):
            return None
        with open(metadata_path, 'r') as f:
            data = json.load(f)
            return data.get("ruleset")

================================================================================
--- FILE: custom_dialogs.py ---
================================================================================

import customtkinter as ctk

class MessageBox(ctk.CTkToplevel):
    """A custom, modern messagebox that matches the application's theme."""

    def __init__(self, parent, title, message, dialog_type="info"):
        super().__init__(parent)

        self.title(title)
        self.transient(parent)
        self.resizable(False, False)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.configure(fg_color="#2B2B2B")

        self.result = None

        # --- FIX: Use a grid layout on the window itself to allow expansion ---
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # --- FIX: Place all widgets inside a main frame that uses the grid ---
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.grid(row=0, column=0, padx=20, pady=20, sticky="nsew")
        main_frame.grid_columnconfigure(0, weight=1)

        # Message Label (packed inside the frame)
        message_label = ctk.CTkLabel(main_frame, text=message, font=ctk.CTkFont(size=14), wraplength=350, justify="center")
        message_label.pack(pady=(0, 20), padx=10, fill="x")

        # Button Frame (packed inside the frame)
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        # --- BUTTON CREATION (Logic is correct, no changes needed here) ---
        if dialog_type in ["info", "error", "warning"]:
            self.result = "ok" # Default result for simple close
            ok_button = ctk.CTkButton(button_frame, text="OK", command=self._on_close, width=80)
            ok_button.pack(padx=10)
            self.bind("<Return>", lambda e: ok_button.invoke())
            ok_button.focus()

        elif dialog_type == "askyesno":
            self.result = False  # Default to 'No' if window is closed
            yes_button = ctk.CTkButton(button_frame, text="Yes", command=lambda: self._set_result_and_close(True), width=80)
            yes_button.pack(side="left", padx=10)
            no_button = ctk.CTkButton(button_frame, text="No", command=lambda: self._set_result_and_close(False), width=80)
            no_button.pack(side="left", padx=10)
            self.bind("<Return>", lambda e: yes_button.invoke())
            no_button.focus()

        elif dialog_type == "askyesnocancel":
            self.result = None  # Default to 'Cancel' if window is closed
            yes_button = ctk.CTkButton(button_frame, text="Yes", command=lambda: self._set_result_and_close(True), width=80)
            yes_button.pack(side="left", padx=10)
            no_button = ctk.CTkButton(button_frame, text="No", command=lambda: self._set_result_and_close(False), width=80)
            no_button.pack(side="left", padx=10)
            cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=lambda: self._set_result_and_close(None), width=80, fg_color="gray50", hover_color="gray40")
            cancel_button.pack(side="left", padx=10)
            self.bind("<Return>", lambda e: yes_button.invoke())
            cancel_button.focus()

        # --- CENTERING AND MODAL LOGIC (No changes needed) ---
        self.update_idletasks()
        # This logic for centering remains fine, but we'll add a fallback for safety
        try:
            parent_geo = parent.geometry().split('+')
            parent_x = int(parent_geo[1])
            parent_y = int(parent_geo[2])
            parent_width = int(parent_geo[0].split('x')[0])
            parent_height = int(parent_geo[0].split('x')[1])
            x = parent_x + (parent_width - self.winfo_width()) // 2
            y = parent_y + (parent_height - self.winfo_height()) // 2
            self.geometry(f"+{x}+{y}")
        except Exception:
            # Fallback in case parent window geometry is unusual
            self.geometry(f"400x200")


        self.grab_set()
        self.wait_window(self)

    def _set_result_and_close(self, result):
        self.result = result
        self._on_close()

    def _on_close(self):
        self.grab_release()
        self.destroy()

    # --- CLASS METHODS (No change needed, they are correct) ---
    @classmethod
    def showinfo(cls, title, message, parent):
        cls(parent, title, message, dialog_type="info")

    @classmethod
    def showerror(cls, title, message, parent):
        cls(parent, title, message, dialog_type="error")

    @classmethod
    def showwarning(cls, title, message, parent):
        cls(parent, title, message, dialog_type="warning")

    @classmethod
    def askyesno(cls, title, message, parent):
        dialog = cls(parent, title, message, dialog_type="askyesno")
        return dialog.result

    @classmethod
    def askyesnocancel(cls, title, message, parent):
        dialog = cls(parent, title, message, dialog_type="askyesnocancel")
        return dialog.result

================================================================================
--- FILE: database.py ---
================================================================================

import sqlite3
import json
import os

class Database:
    def __init__(self, campaign_path):
        self.db_path = os.path.join(campaign_path, 'campaign.db')
        self.conn = None

    def connect(self):
        """Establishes a connection to the database."""
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row

    def close(self):
        """Closes the database connection."""
        if self.conn:
            self.conn.close()

    def execute(self, query, params=()):
        """Executes a query that doesn't return data (INSERT, UPDATE, DELETE)."""
        cursor = self.conn.cursor()
        cursor.execute(query, params)
        self.conn.commit()

    def fetchone(self, query, params=()):
        """Fetches a single record."""
        cursor = self.conn.cursor()
        cursor.execute(query, params)
        return cursor.fetchone()

    def fetchall(self, query, params=()):
        """Fetches all records."""
        cursor = self.conn.cursor()
        cursor.execute(query, params)
        return cursor.fetchall()

    def initialize_schema(self):
        """Creates all necessary tables if they don't exist."""
        if not self.conn:
            self.connect()
        
        # Using TEXT to store JSON blobs for flexibility.
        # Indexing key fields for fast lookups.
        schema = [
            """
            CREATE TABLE IF NOT EXISTS characters (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                rule_set TEXT NOT NULL,
                data TEXT NOT NULL
            );
            """,
            "CREATE INDEX IF NOT EXISTS idx_char_name ON characters (name);",
            "CREATE INDEX IF NOT EXISTS idx_char_ruleset ON characters (rule_set);",
            """
            CREATE TABLE IF NOT EXISTS npcs (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                rule_set TEXT NOT NULL,
                data TEXT NOT NULL
            );
            """,
            "CREATE INDEX IF NOT EXISTS idx_npc_name ON npcs (name);",
            "CREATE INDEX IF NOT EXISTS idx_npc_ruleset ON npcs (rule_set);",
            """
            CREATE TABLE IF NOT EXISTS items (
                id TEXT PRIMARY KEY,
                data TEXT NOT NULL
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS quests (
                id TEXT PRIMARY KEY,
                data TEXT NOT NULL
            );
            """
        ]
        
        cursor = self.conn.cursor()
        for statement in schema:
            cursor.execute(statement)
        self.conn.commit()
        self.close()


================================================================================
--- FILE: main.py ---
================================================================================

import customtkinter as ctk
from app_controller import AppController

if __name__ == "__main__":
    ctk.set_appearance_mode("Dark")
    ctk.set_default_color_theme("blue")

    root = ctk.CTk()
    root.title("TTRPG Campaign Editor")

    # --- FIX: Set the window to start in fullscreen mode ---
    root.attributes('-fullscreen', True)
    
    # These are still good to have as fallbacks if the user exits fullscreen
    root.geometry("1200x800")
    root.minsize(1000, 700)

    # The AppController now manages everything, including screen switching
    app = AppController(root)
    app.run()

================================================================================
--- FILE: main_menu_view.py ---
================================================================================

import customtkinter as ctk
import threading
import queue

class MainMenuView(ctk.CTkFrame):
    """The UI for the main menu screen, featuring a clean vertical layout."""
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        self.load_game_window = None

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        ctk.CTkLabel(self, text="TTRPG Campaign Editor", font=ctk.CTkFont(size=32, weight="bold")).grid(
            row=0, column=0, pady=(50, 30))
        
        menu_frame = ctk.CTkFrame(self, fg_color="transparent")
        menu_frame.grid(row=1, column=0, sticky="n")

        button_width = 250
        button_height = 50
        button_pady = 10

        ctk.CTkButton(
            menu_frame, text="New Game", width=button_width, height=button_height,
            command=self.controller.new_game_flow
        ).pack(pady=button_pady)
        
        ctk.CTkButton(
            menu_frame, text="Load Game", width=button_width, height=button_height,
            command=self.show_load_game_window
        ).pack(pady=button_pady)
        
        ctk.CTkButton(
            menu_frame, text="Create New Ruleset", width=button_width, height=button_height,
            command=self.controller.show_ruleset_creator_standalone
        ).pack(pady=button_pady)
        
        ctk.CTkButton(
            menu_frame, text="Edit Rulesets", width=button_width, height=button_height,
            command=self.controller.show_placeholder_message, state="disabled"
        ).pack(pady=button_pady)
        
        ctk.CTkButton(
            menu_frame, text="Settings", width=button_width, height=button_height,
            command=self.controller.show_placeholder_message, state="disabled"
        ).pack(pady=button_pady)
        
        ctk.CTkButton(
            menu_frame, text="Exit", width=button_width, height=button_height,
            command=self.controller.exit_app, fg_color="#D2691E", hover_color="#B2590E"
        ).pack(pady=(30, 10))

    def show_load_game_window(self):
        """Creates and displays the 'Load Game' pop-up window."""
        if self.load_game_window is None or not self.load_game_window.winfo_exists():
            self.load_game_window = LoadGameWindow(self, self.controller)
            self.load_game_window.grab_set()
        else:
            self.load_game_window.focus()

class LoadGameWindow(ctk.CTkToplevel):
    """A pop-up window that asynchronously loads and displays saved campaigns."""
    def __init__(self, parent_view, controller):
        super().__init__(parent_view)
        self.controller = controller
        self.selected_campaign = None
        self.campaign_buttons = []

        self.title("Load Game")
        self.geometry("400x500")
        self.configure(fg_color="#2B2B2B")
        self.resizable(False, False)
        
        self.protocol("WM_DELETE_WINDOW", self._on_close) # Handle 'X' button
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        ctk.CTkLabel(self, text="Select a Campaign", font=ctk.CTkFont(size=18, weight="bold")).grid(row=0, column=0, pady=10)

        self.campaign_list_frame = ctk.CTkScrollableFrame(self, label_text="Existing Campaigns")
        self.campaign_list_frame.grid(row=1, column=0, sticky="nsew", padx=10)
        
        self.loading_label = ctk.CTkLabel(self.campaign_list_frame, text="Loading...")
        self.loading_label.pack(pady=20)

        ctk.CTkButton(self, text="Load Selected", command=self._load_and_close).grid(row=2, column=0, pady=10)

        self.campaign_queue = queue.Queue()
        self.worker_thread = threading.Thread(target=self._fetch_campaigns_worker, daemon=True)
        self.worker_thread.start()
        self.after(100, self._process_queue)

    def _fetch_campaigns_worker(self):
        """(Runs on a background thread) Fetches the list of campaigns."""
        campaigns = self.controller.campaign_model.list_campaigns()
        self.campaign_queue.put(campaigns)

    def _process_queue(self):
        """(Runs on the main GUI thread) Checks for results from the worker thread."""
        try:
            campaigns = self.campaign_queue.get_nowait()
            self._populate_list_ui(campaigns)
        except queue.Empty:
            if self.winfo_exists():
                self.after(100, self._process_queue)

    def _populate_list_ui(self, campaigns):
        """(Runs on the main GUI thread) Clears old widgets and builds the button list."""
        self.loading_label.destroy()
        for btn in self.campaign_buttons:
            btn.destroy()
        self.campaign_buttons.clear()
        self.selected_campaign = None

        if not campaigns:
            ctk.CTkLabel(self.campaign_list_frame, text="No saved games found.").pack()
        else:
            for name in campaigns:
                btn = ctk.CTkButton(self.campaign_list_frame, text=name, 
                                    command=lambda n=name: self._on_campaign_select(n),
                                    fg_color="transparent", border_width=1, border_color="gray50")
                btn.pack(pady=2, padx=5, fill="x")
                self.campaign_buttons.append(btn)
    
    def _on_campaign_select(self, campaign_name):
        self.selected_campaign = campaign_name
        for btn in self.campaign_buttons:
            if btn.cget("text") == campaign_name:
                btn.configure(fg_color="#3B8ED0", border_color="#3B8ED0")
            else:
                btn.configure(fg_color="transparent", border_color="gray50")
    
    def _on_close(self):
        """Ensures the grab is released before destroying the window."""
        self.grab_release()
        self.destroy()

    def _load_and_close(self):
        """Schedules the loading operation and safely closes the pop-up."""
        campaign_to_load = self.selected_campaign
        self._on_close() # Use the safe closing method
        if campaign_to_load:
            self.controller.root.after(50, lambda: self.controller.load_game_flow(campaign_to_load))

class NewCampaignDialog(ctk.CTkToplevel):
    def __init__(self, parent, rulesets):
        super().__init__(parent)
        self.title("New Campaign")
        self.geometry("400x300")
        self.configure(fg_color="#2B2B2B")
        self.resizable(False, False)
        
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        
        self.result = None
        self.grid_columnconfigure(0, weight=1)

        ctk.CTkLabel(self, text="Create New Campaign", font=ctk.CTkFont(size=20, weight="bold")).pack(pady=(20, 10))
        
        # Name Input
        ctk.CTkLabel(self, text="Campaign Name:", anchor="w").pack(pady=(5, 0), padx=20, fill="x")
        self.name_entry = ctk.CTkEntry(self, width=300)
        self.name_entry.pack(pady=(0, 10), padx=20, fill="x")
        
        # Ruleset Selection
        ctk.CTkLabel(self, text="Choose Rule Set:", anchor="w").pack(pady=(5, 0), padx=20, fill="x")
        self.combobox = ctk.CTkComboBox(self, values=rulesets, state="readonly", width=300)
        self.combobox.pack(pady=(0, 10), padx=20, fill="x")
        if rulesets:
            self.combobox.set(rulesets[0])
        
        # Buttons
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(pady=20)
        ctk.CTkButton(button_frame, text="Create Campaign", command=self._on_ok).pack(side="left", padx=10)
        ctk.CTkButton(button_frame, text="Cancel", command=self._on_close).pack(side="left", padx=10)

        self.transient(parent) # Set as modal

        # --- FIX: Ensure the window is viewable before making it modal ---
        self.update_idletasks()

        self.grab_set()
        self.wait_window(self)

    def _on_close(self):
        self.grab_release()
        self.destroy()

    def _on_ok(self):
        campaign_name = self.name_entry.get().strip()
        ruleset_name = self.combobox.get()
        
        if not campaign_name or not ruleset_name or ruleset_name == "No rule sets found":
            self.result = None
            self._on_close()
            return
            
        self.result = (campaign_name, ruleset_name)
        self._on_close()

    def get_input(self):
        return self.result

================================================================================
--- FILE: projectpacker.py ---
================================================================================

import os

# --- Configuration ---
OUTPUT_FILENAME = "project_snapshot.txt"
EXCLUDED_DIRS = {".git", "venv", "__pycache__", ".idea", ".vscode"}
EXCLUDED_FILES = {OUTPUT_FILENAME, "project_snapshot.txt.py", ".gitignore"}

def write_directory_tree(start_path, output_file, exclusions):
    """Walks through the directory and writes a tree structure to the file."""
    for root, dirs, files in os.walk(start_path, topdown=True):
        # Exclude specified directories from traversal
        dirs[:] = [d for d in dirs if d not in exclusions]
        
        level = root.replace(start_path, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write(f'{indent}📂 {os.path.basename(root)}/\n')
        
        sub_indent = ' ' * 4 * (level + 1)
        for f in sorted(files):
            if f not in exclusions:
                output_file.write(f'{sub_indent}📄 {f}\n')

def write_python_files_content(start_path, output_file, exclusions):
    """Walks through the directory and appends the content of all .py files."""
    for root, dirs, files in os.walk(start_path, topdown=True):
        # Exclude specified directories
        dirs[:] = [d for d in dirs if d not in exclusions]
        
        for f in sorted(files):
            if f.endswith('.py') and f not in exclusions:
                file_path = os.path.join(root, f)
                relative_path = os.path.relpath(file_path, start_path)
                
                output_file.write("\n" + "="*80 + "\n")
                output_file.write(f"--- FILE: {relative_path} ---\n")
                output_file.write("="*80 + "\n\n")
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as py_file:
                        output_file.write(py_file.read())
                except Exception as e:
                    output_file.write(f"*** ERROR READING FILE: {e} ***")
                output_file.write("\n")

def main():
    """Main function to generate the project snapshot."""
    start_path = '.'
    try:
        with open(OUTPUT_FILENAME, 'w', encoding='utf-8') as f:
            f.write("="*80 + "\n")
            f.write("PROJECT DIRECTORY STRUCTURE\n")
            f.write("="*80 + "\n\n")
            write_directory_tree(start_path, f, EXCLUDED_DIRS)
            
            f.write("\n\n" + "="*80 + "\n")
            f.write("PYTHON FILE CONTENTS\n")
            f.write("="*80 + "\n")
            write_python_files_content(start_path, f, EXCLUDED_DIRS.union(EXCLUDED_FILES))

        print(f"✅ Successfully created '{OUTPUT_FILENAME}'")
        print("You can now send the content of this file in the next chat.")

    except Exception as e:
        print(f"❌ An error occurred: {e}")

if __name__ == "__main__":
    main()


================================================================================
--- FILE: ui_extensions.py ---
================================================================================

import customtkinter as ctk

class AutoWidthComboBox(ctk.CTkComboBox):
    """
    A custom CTkComboBox that overrides the dropdown menu creation
    to enforce a specific width and add borders to the options.
    This version uses the after() method and directly configures the
    internal buttons, which is the definitive solution.
    """
    def _open_dropdown_menu(self):
        # Allow the original method to create the dropdown menu
        super()._open_dropdown_menu()

        # Schedule the configuration to run after a short delay
        # to ensure the main widget's geometry is calculated.
        self.after(20, self._configure_dropdown_menu_geometry)

    def _configure_dropdown_menu_geometry(self):
        """(Runs after a short delay) Applies the correct width and styling."""
        if self._dropdown_menu is not None and hasattr(self._dropdown_menu, '_buttons'):
            # Get the final, rendered width of the combobox widget
            widget_width = self.winfo_width()
            
            # --- FIX: Iterate through all buttons and configure them directly ---
            # This forces the parent frame and window to expand correctly.
            for button in self._dropdown_menu._buttons.values():
                button.configure(
                    width=widget_width,      # Force button width
                    anchor="w",              # Align text to the left
                    corner_radius=0,         # Make options look like a standard menu
                    border_width=1,
                    border_color="gray40"
                )

================================================================================
--- FILE: utils.py ---
================================================================================

import sys
import os

def resource_path(relative_path):
    """
    Get the absolute path to a resource, works for dev and for PyInstaller.
    This is the standard, recommended way to handle assets in a bundled app.
    """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        # If not bundled, the base path is the directory of the main script
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

================================================================================
--- FILE: music/music_controller.py ---
================================================================================

from tkinter import filedialog
from .music_model import MusicModel
from .music_view import MusicView
from custom_dialogs import MessageBox
try:
    import pygame
except ImportError:
    pygame = None

class MusicController:
    """Controller for the Music Player feature."""
    def __init__(self, app_controller, parent_frame):
        self.app_controller = app_controller
        self.model = MusicModel()
        self.view = MusicView(parent_frame)
        self.view.setup_ui(self)
        self.refresh_music_list()

    def refresh_music_list(self):
        """Gets the updated song list from the model and tells the view to display it."""
        songs = self.model.get_music_files()
        self.view.update_music_list(songs)

    def add_music(self):
        """Opens a file dialog for the user to select music files to add."""
        file_types = [("Audio Files", "*.mp3 *.wav"), ("All files", "*.*")]
        source_paths = filedialog.askopenfilenames(title="Select Music Files", filetypes=file_types)
        
        if not source_paths: return
            
        copied_count = self.model.add_music_files(source_paths)
        
        if copied_count > 0:
            MessageBox.showinfo("Music Added", f"Successfully added {copied_count} new song(s).", self.view.parent_frame)
            self.refresh_music_list()
        else:
            MessageBox.showwarning("No Music Added", "No new files were added. They may have already existed or there was an error.", self.view.parent_frame)
    
    def handle_play_pause(self):
        """Smart handler for the combined Play/Pause button."""
        if not pygame:
            return

        selected_song = self.view.music_list.get()
        if not selected_song or "No music" in selected_song:
            return

        # --- FIX: Simplified and corrected logic ---
        # If a different song is selected from the dropdown, it MUST be a fresh play.
        if self.model.current_song != selected_song:
            self.model.play(selected_song)
        # Otherwise, the song is the same, so we simply toggle between pause and unpause.
        else:
            self.model.toggle_pause()

    def stop_song(self):
        self.model.stop()

    def set_volume(self, volume):
        self.model.set_volume(volume)

================================================================================
--- FILE: music/music_model.py ---
================================================================================

import os
import shutil
from utils import resource_path
try:
    import pygame
except ImportError:
    print("Pygame not found. Music player functionality will be disabled.")
    pygame = None

class MusicModel:
    """Model for handling audio playback and file management."""
    def __init__(self, music_dir_name='assets/music'):
        self.music_dir = resource_path(music_dir_name)
        if not os.path.exists(self.music_dir):
            os.makedirs(self.music_dir)
        if pygame:
            pygame.mixer.init()
        
        self.paused = False
        self.current_song = None

    def get_music_files(self):
        """Returns a sorted list of music files in the assets directory."""
        if not pygame: return ["Pygame not installed"]
        try:
            return sorted([f for f in os.listdir(self.music_dir) if f.endswith(('.mp3', '.wav'))])
        except FileNotFoundError:
            return []
            
    def add_music_files(self, source_paths):
        """Copies music files from a list of source paths to the assets directory."""
        copied_count = 0
        for src_path in source_paths:
            if not os.path.exists(src_path):
                continue
            
            filename = os.path.basename(src_path)
            dest_path = os.path.join(self.music_dir, filename)
            
            try:
                shutil.copy(src_path, dest_path)
                copied_count += 1
            except shutil.Error as e:
                print(f"Error copying file {filename}: {e}")
            except IOError as e:
                print(f"I/O error copying file {filename}: {e}")
        return copied_count

    def play(self, song_name):
        """Loads and plays a new song, resetting the paused state."""
        if not pygame or not song_name: return
        filepath = os.path.join(self.music_dir, song_name)
        if os.path.exists(filepath):
            pygame.mixer.music.load(filepath)
            pygame.mixer.music.play(-1)
            self.paused = False
            self.current_song = song_name

    def toggle_pause(self):
        """Correctly toggles pause/unpause using a state flag."""
        if not pygame: return
        
        # --- FIX: Removed the flawed get_busy() check ---
        # This allows the function to work correctly when unpausing.

        if self.paused:
            pygame.mixer.music.unpause()
            self.paused = False
        else:
            # Only try to pause if a song is actually loaded and playing
            if pygame.mixer.music.get_busy():
                pygame.mixer.music.pause()
                self.paused = True

    def stop(self):
        """Stops the music and unloads the file to fully clear the state."""
        if not pygame: return
        pygame.mixer.music.stop()
        pygame.mixer.music.unload()
        self.paused = False
        self.current_song = None

    def set_volume(self, volume):
        if not pygame: return
        pygame.mixer.music.set_volume(float(volume))

================================================================================
--- FILE: music/music_view.py ---
================================================================================

import customtkinter as ctk

class MusicView:
    """Manages the UI for the Music Player panel, designed for a compact header layout."""
    def __init__(self, parent_frame):
        self.parent_frame = parent_frame

    def setup_ui(self, controller):
        """Builds a horizontal music player UI."""
        music_frame = ctk.CTkFrame(self.parent_frame, fg_color="transparent")
        music_frame.pack(side="right", padx=10, pady=5)
        
        # --- FIX: The ComboBox is now ONLY a selector. The 'command' is removed. ---
        self.music_list = ctk.CTkComboBox(music_frame, width=150)
        self.music_list.pack(side="left", padx=5)

        # The Play/Pause button is the single point of action.
        ctk.CTkButton(music_frame, text="▶❚❚", width=40, command=controller.handle_play_pause).pack(side="left", padx=(5, 2))
        ctk.CTkButton(music_frame, text="■", width=30, command=controller.stop_song).pack(side="left", padx=2)
        
        volume_slider = ctk.CTkSlider(music_frame, from_=0, to=1, width=100, command=controller.set_volume)
        volume_slider.set(0.5)
        volume_slider.pack(side="left", padx=(10, 5))

        ctk.CTkButton(music_frame, text="+", width=30, command=controller.add_music).pack(side="left", padx=5)
        
    def update_music_list(self, songs):
        """Refreshes the combobox with the list of available songs."""
        current_song = self.music_list.get()
        self.music_list.configure(values=songs or ["No music files"])
        
        if current_song in songs:
            self.music_list.set(current_song)
        elif songs:
            self.music_list.set(songs[0])
        else:
            self.music_list.set("")

================================================================================
--- FILE: map/map_controller.py ---
================================================================================

from tkinter import messagebox
from .map_model import MapModel
from .map_view import MapView
from .map_generation.map_generation_controller import MapGenerationController
from custom_dialogs import MessageBox
from character.character_controller import CharacterController
from npc.npc_controller import NpcController
import customtkinter as ctk
import math
import os

class MapController:
    """Controller for the self-contained Map feature."""
    def __init__(self, app_controller, parent_frame, campaign_path):
        self.app_controller = app_controller
        self.view = MapView(parent_frame)
        self.campaign_path = campaign_path
        self.model = None
        self.current_level = 0
        self.current_tool = "select"
        self.editor_start_pos = None
        self.selected_tokens = []
        self.token_being_dragged = None
        self.drag_start_pos = {}
        self.drag_preview_pos = None
        self.view.setup_ui(self)
        self._initialize_blank_state()

    def _initialize_blank_state(self):
        self.model = None
        self.current_level = 0
        self.selected_tokens = []
        self.view.clear_all_canvases()
        if hasattr(self.view, 'map_name_entry'):
            self.view.map_name_entry.delete(0, 'end')
        self.view.update_level_controls(None, 0)
        self.refresh_map_list()

    def handle_rule_set_load(self, rule_set):
        self.update_token_placer_list()

    def show_new_map_dialog(self):
        if self.model and self.app_controller.unsaved_changes:
            if not MessageBox.askyesno("Unsaved Changes", "This will erase the current unsaved map design. Are you sure?", self.view.parent_frame):
                return
        gen_controller = MapGenerationController(parent_view=self.view.parent_frame)
        map_data = gen_controller.show_generation_dialog()
        if map_data:
            self.load_new_map_data(map_data)

    def load_new_map_data(self, map_data):
        self.model = MapModel(self.campaign_path, name="New Generated Map", width=map_data['width'], height=map_data['height'], grid_scale=map_data['grid_scale'])
        self.model.map_type = map_data['map_type']
        self.model.levels = map_data['levels']
        self.current_level = 0
        self.selected_tokens = []
        self.view.map_name_entry.delete(0, 'end')
        self.view.map_name_entry.insert(0, self.model.name)
        self.view.update_dimension_fields(self.model)
        self.set_tool("select")
        self._sync_and_redraw_all_views()
        self.app_controller.set_dirty_flag(True)

    def change_level(self, delta):
        if not self.model or self.model.map_type != 'inside': return
        new_level = self.current_level + delta
        if new_level in self.model.levels:
            self.current_level = new_level
            self.selected_tokens = []
            self._sync_and_redraw_all_views()
        else:
            if MessageBox.askyesno("Create New Level?", f"Level {new_level} does not exist. Would you like to create a new blank level?", self.view.parent_frame):
                self.model.levels[new_level] = {'elements': [], 'tokens': [], 'landmarks': []}
                self.model.clear_map_level(new_level)
                self.current_level = new_level
                self.selected_tokens = []
                self._sync_and_redraw_all_views()
                self.app_controller.set_dirty_flag(True)

    def update_token_placer_list(self):
        char_controller = self.app_controller.get_loaded_controller(CharacterController)
        npc_controller = self.app_controller.get_loaded_controller(NpcController)
        pc_list, npc_list = [], []
        if char_controller:
            pc_models = char_controller.get_character_list()
            pc_list = [f"PC: {model.name}" for model in pc_models]
        if npc_controller:
            npc_models = npc_controller.get_npc_list()
            npc_list = [f"NPC: {model.name}" for model in npc_models]
        self.view.update_token_placer_list(pc_list + npc_list)

    def set_tool(self, tool_name):
        self.current_tool = tool_name
        if tool_name in ["brush", "rect"]:
            self.selected_tokens = []
            if self.model: self._redraw_viewer_canvas()

    # --- FIX: Restored missing canvas event handlers ---
    def on_editor_canvas_press(self, event):
        if not self.model: return
        self.editor_start_pos = (event.x, event.y)
        if self.current_tool == "landmark":
            landmark_text = self.view.landmark_text_entry.get()
            if not landmark_text:
                MessageBox.showwarning("Warning", "Please enter text for the landmark first.", self.view.parent_frame)
                return
            x_grid, y_grid = event.x // self.model.grid_size, event.y // self.model.grid_size
            self.model.add_landmark(x_grid, y_grid, landmark_text, self.current_level)
            self._sync_and_redraw_all_views()
            self.app_controller.set_dirty_flag()
            self.set_tool("select")

    def on_editor_canvas_drag(self, event):
        if not self.model: return
        if self.current_tool == "brush":
            x, y = event.x // self.model.grid_size, event.y // self.model.grid_size
            self.model.add_element({'type': 'rect', 'coords': (x, y, x + 1, y + 1), 'color': self.view.color_var.get()}, self.current_level)
            self.view.draw_editor_canvas(self.model, self.current_level)
            self.app_controller.set_dirty_flag()

    def on_editor_canvas_release(self, event):
        if not self.model: return
        if self.current_tool == "rect" and self.editor_start_pos:
            x0 = min(self.editor_start_pos[0], event.x) // self.model.grid_size
            y0 = min(self.editor_start_pos[1], event.y) // self.model.grid_size
            x1 = max(self.editor_start_pos[0], event.x) // self.model.grid_size
            y1 = max(self.editor_start_pos[1], event.y) // self.model.grid_size
            self.model.add_element({'type': 'rect', 'coords': (x0, y0, x1 + 1, y1 + 1), 'color': self.view.color_var.get()}, self.current_level)
            self._sync_and_redraw_all_views()
            self.app_controller.set_dirty_flag()
        self.editor_start_pos = None

    def on_viewer_canvas_press(self, event):
        if not self.model: return
        x_grid, y_grid = event.x // self.model.grid_size, event.y // self.model.grid_size
        if self.current_tool == "place_token":
            token_str = self.view.token_placer_list.get()
            if not token_str or "No tokens" in token_str or "Load" in token_str: return
            token_type, token_name = token_str.split(': ', 1)
            if self.model.add_token(token_name.strip(), token_type, x_grid, y_grid, self.current_level):
                self._redraw_viewer_canvas()
                self.app_controller.set_dirty_flag()
            else:
                MessageBox.showwarning("Warning", f"Token '{token_name.strip()}' is already on the map.", self.view.parent_frame)
            self.set_tool("select")
            return
        clicked_token = self.model.get_token_at(x_grid, y_grid, self.current_level)
        if clicked_token:
            self.token_being_dragged = clicked_token
            self.drag_start_pos[clicked_token['name']] = (clicked_token['x'], clicked_token['y'])
            if clicked_token not in self.selected_tokens:
                self.selected_tokens = [clicked_token]
        else:
            self.selected_tokens = []
        self._update_distance_display()
        self._redraw_viewer_canvas()

    def on_viewer_canvas_ctrl_press(self, event):
        if not self.model: return
        x_grid, y_grid = event.x // self.model.grid_size, event.y // self.model.grid_size
        clicked_token = self.model.get_token_at(x_grid, y_grid, self.current_level)
        if clicked_token:
            if clicked_token in self.selected_tokens:
                self.selected_tokens.remove(clicked_token)
            else:
                self.selected_tokens.append(clicked_token)
            self._update_distance_display()
            self._redraw_viewer_canvas()

    def on_viewer_canvas_drag(self, event):
        if not self.token_being_dragged: return
        mouse_x, mouse_y = event.x, event.y
        try: move_dist_m = float(self.view.movement_entry.get() or 0)
        except ValueError: move_dist_m = 0
        start_grid_x, start_grid_y = self.drag_start_pos[self.token_being_dragged['name']]
        start_pixel_x = (start_grid_x + 0.5) * self.model.grid_size
        start_pixel_y = (start_grid_y + 0.5) * self.model.grid_size
        if move_dist_m > 0:
            dist_moved_pixels = math.sqrt((mouse_x - start_pixel_x)**2 + (mouse_y - start_pixel_y)**2)
            max_dist_pixels = (move_dist_m / self.model.grid_scale) * self.model.grid_size
            if dist_moved_pixels > max_dist_pixels and dist_moved_pixels > 0:
                angle = math.atan2(mouse_y - start_pixel_y, mouse_x - start_pixel_x)
                clamped_x = start_pixel_x + max_dist_pixels * math.cos(angle)
                clamped_y = start_pixel_y + max_dist_pixels * math.sin(angle)
                self.drag_preview_pos = (clamped_x, clamped_y)
            else:
                self.drag_preview_pos = (mouse_x, mouse_y)
        else:
            self.drag_preview_pos = (mouse_x, mouse_y)
        self._redraw_viewer_canvas()

    def on_viewer_canvas_release(self, event):
        if self.token_being_dragged and self.drag_preview_pos:
            final_x = int(self.drag_preview_pos[0] // self.model.grid_size)
            final_y = int(self.drag_preview_pos[1] // self.model.grid_size)
            if (self.token_being_dragged['x'], self.token_being_dragged['y']) != (final_x, final_y):
                self.model.move_token(self.token_being_dragged['name'], final_x, final_y, self.current_level)
                self.app_controller.set_dirty_flag()
        self.token_being_dragged = None
        self.drag_start_pos = {}
        self.drag_preview_pos = None
        self._redraw_viewer_canvas()

    def _update_distance_display(self):
        if len(self.selected_tokens) == 2:
            dist_grid = self.model.calculate_distance(self.selected_tokens[0], self.selected_tokens[1])
            dist_m = dist_grid * self.model.grid_scale
            self.view.distance_label.configure(text=f"{dist_m:.1f} m")
        else:
            self.view.distance_label.configure(text="-")

    def _sync_and_redraw_all_views(self):
        if not self.model: return
        self.view.update_level_controls(self.model, self.current_level)
        self.view.draw_editor_canvas(self.model, self.current_level)
        self.view.draw_static_background(self.model, self.current_level)
        self.view.draw_viewer_canvas(self.model, self)

    def _redraw_editor_view_only(self):
        if not self.model: return
        self.view.update_level_controls(self.model, self.current_level)
        self.view.draw_editor_canvas(self.model, self.current_level)
        
    def _redraw_viewer_canvas(self):
        if not self.model: return
        self.view.draw_viewer_canvas(self.model, self)

    def save_map(self):
        if not self.model:
            MessageBox.showerror("Error", "There is no map to save.", self.view.parent_frame)
            return
        map_name = self.view.map_name_entry.get()
        if not map_name or map_name == "New Generated Map":
            MessageBox.showerror("Error", "Please enter a unique name for the map.", self.view.parent_frame)
            return
        self.model.name = map_name
        try:
            self.model.grid_scale = float(self.view.scale_entry.get())
        except ValueError:
            MessageBox.showerror("Error", "Invalid grid scale.", self.view.parent_frame)
            return
        self.model.save_map_data()
        png_path = os.path.join(self.model.maps_dir, f"{self.model.name.lower().replace(' ', '_')}.png")
        if not self.view.save_canvas_to_png(png_path, self.model, self.current_level):
            MessageBox.showerror("Error", "Failed to save map image.", self.view.parent_frame)
            return
        self.app_controller.set_dirty_flag(False)
        self.refresh_map_list()
        MessageBox.showinfo("Success", f"Map '{self.model.name}' has been saved.", self.view.parent_frame)

    def refresh_map_list(self):
        maps = MapModel.get_all_maps(self.campaign_path)
        self.view.update_map_list(maps)
        
    def load_map_for_viewing(self, map_name):
        if "Select a saved map..." in map_name:
            self._initialize_blank_state()
            return
        loaded_model = MapModel.load(self.campaign_path, map_name)
        if loaded_model:
            self.model = loaded_model
            self.current_level = 0
            self.selected_tokens = []
            self.view.map_name_entry.delete(0, 'end')
            self.view.map_name_entry.insert(0, self.model.name)
            self.view.update_dimension_fields(self.model)
            self.set_tool("select")
            self._sync_and_redraw_all_views()
            self.app_controller.set_dirty_flag(False)
        else:
            MessageBox.showerror("Error", f"Could not load map data for '{map_name}'.", self.view.parent_frame)

    def delete_selected_tokens(self):
        if not self.selected_tokens:
            MessageBox.showinfo("Info", "No tokens selected to delete.", self.view.parent_frame)
            return
        if MessageBox.askyesno("Confirm", f"Are you sure you want to delete {len(self.selected_tokens)} token(s)?", self.view.parent_frame):
            for token in self.selected_tokens:
                self.model.delete_token(token['name'], self.current_level)
            self.selected_tokens = []
            self._update_distance_display()
            self._redraw_viewer_canvas()
            self.app_controller.set_dirty_flag(True)

================================================================================
--- FILE: map/map_model.py ---
================================================================================

import json
import os
import random
import math

class MapModel:
    """Manages map data, supporting multiple levels and landmarks."""
    def __init__(self, campaign_path, name="New Map", width=50, height=50, grid_size=20, grid_scale=1.5):
        self.campaign_path = campaign_path
        self.name = name
        self.width = width
        self.height = height
        self.grid_size = grid_size
        self.grid_scale = grid_scale
        
        self.map_type = "outside"
        # --- NEW: Add a 'landmarks' list to each level ---
        self.levels = {0: {'elements': [], 'tokens': [], 'landmarks': []}}
        
        self.maps_dir = os.path.join(self.campaign_path, 'maps')
        if not os.path.exists(self.maps_dir):
            os.makedirs(self.maps_dir)

    def clear_map_level(self, level_index=0):
        """Clears all elements, tokens, and landmarks from a specific level."""
        if level_index not in self.levels:
            self.levels[level_index] = {'elements': [], 'tokens': [], 'landmarks': []}
        else:
            self.levels[level_index]['elements'].clear()
            self.levels[level_index]['landmarks'].clear()
        
        self.add_element({'type': 'rect', 'coords': (0, 0, self.width, self.height), 'color': '#2B2B2B'}, level_index)


    def add_element(self, element, level_index=0):
        if level_index in self.levels:
            self.levels[level_index]['elements'].append(element)
    
    def add_landmark(self, x, y, text, level_index=0):
        """Adds a new landmark to the specified level."""
        if level_index in self.levels:
            self.levels[level_index]['landmarks'].append({'x': x, 'y': y, 'text': text})

    def add_token(self, name, token_type, x, y, level_index=0):
        if level_index not in self.levels: return False
        if any(t['name'] == name for t in self.get_all_tokens()): return False
        self.levels[level_index]['tokens'].append({'name': name, 'type': token_type, 'x': x, 'y': y})
        return True

    def delete_token(self, token_name, level_index=0):
        if level_index in self.levels:
            self.levels[level_index]['tokens'] = [t for t in self.levels[level_index]['tokens'] if t.get('name') != token_name]

    def move_token(self, token_name, new_x, new_y, level_index=0):
        if level_index in self.levels:
            for token in self.levels[level_index]['tokens']:
                if token['name'] == token_name:
                    token['x'] = new_x
                    token['y'] = new_y
                    return True
        return False
        
    def get_token_at(self, x, y, level_index=0):
        if level_index not in self.levels: return None
        for token in reversed(self.levels[level_index]['tokens']):
            if math.sqrt((x - token['x'])**2 + (y - token['y'])**2) < 0.5:
                return token
        return None

    def get_all_tokens(self):
        all_tokens = []
        for level_data in self.levels.values():
            all_tokens.extend(level_data['tokens'])
        return all_tokens

    def calculate_distance(self, token1, token2):
        return math.sqrt((token1['x'] - token2['x'])**2 + (token1['y'] - token2['y'])**2)

    def save_map_data(self):
        json_path = os.path.join(self.maps_dir, f"{self.name.lower().replace(' ', '_')}.json")
        map_data = {
            'name': self.name, 'width': self.width, 'height': self.height, 
            'grid_size': self.grid_size, 'grid_scale': self.grid_scale,
            'map_type': self.map_type,
            'levels': self.levels,
        }
        with open(json_path, 'w') as f:
            json.dump(map_data, f, indent=4)

    @staticmethod
    def load(campaign_path, map_name):
        maps_dir = os.path.join(campaign_path, 'maps')
        json_path = os.path.join(maps_dir, f"{map_name.lower().replace(' ', '_')}.json")
        if not os.path.exists(json_path): return None
        with open(json_path, 'r') as f:
            data = json.load(f)
            map_instance = MapModel(
                campaign_path, data['name'], data['width'], data['height'], 
                data.get('grid_size', 20), data.get('grid_scale', 1.5)
            )
            map_instance.map_type = data.get('map_type', 'outside')
            
            if 'map_elements' in data:
                 map_instance.levels = {0: {
                     'elements': data.get('map_elements', []), 
                     'tokens': data.get('tokens', []),
                     'landmarks': data.get('landmarks', []) # Legacy support
                }}
            else:
                 map_instance.levels = data.get('levels', {0: {'elements': [], 'tokens': [], 'landmarks': []}})
                 map_instance.levels = {int(k): v for k, v in map_instance.levels.items()}
                 # Ensure landmarks key exists for older saves
                 for level_data in map_instance.levels.values():
                     if 'landmarks' not in level_data:
                         level_data['landmarks'] = []
            return map_instance

    @staticmethod
    def get_all_maps(campaign_path):
        maps_dir = os.path.join(campaign_path, 'maps')
        if not os.path.exists(maps_dir): return []
        return sorted([f.replace('.json', '').replace('_', ' ').title() for f in os.listdir(maps_dir) if f.endswith('.json')])

================================================================================
--- FILE: map/map_view.py ---
================================================================================

import customtkinter as ctk
from PIL import Image, ImageTk, ImageDraw
import os
from ui_extensions import AutoWidthComboBox

class MapView:
    """Manages the UI for the self-contained Map feature."""
    def __init__(self, parent_frame):
        # The parent frame will manage this view's frame with grid
        parent_frame.grid_rowconfigure(0, weight=1)
        parent_frame.grid_columnconfigure(0, weight=1)

        self.frame = ctk.CTkTabview(parent_frame, fg_color="transparent")
        self.frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        self.editor_tab = self.frame.add("Editor")
        self.viewer_tab = self.frame.add("Viewer")

        self.map_photo_image = None
        self.PC_COLOR = "#00BFFF"
        self.NPC_COLOR = "#DC143C"

    def setup_ui(self, controller):
        """Calls the setup methods for both internal tabs."""
        self.setup_editor_ui(controller)
        self.setup_viewer_ui(controller)

    def setup_editor_ui(self, controller):
        """Builds the UI for the Map Editor tab."""
        self.editor_tab.grid_columnconfigure(1, weight=1)
        self.editor_tab.grid_rowconfigure(0, weight=1)
        
        toolbar = ctk.CTkFrame(self.editor_tab, width=220)
        toolbar.grid(row=0, column=0, sticky="ns", padx=10, pady=10)
        
        # ... (Toolbar setup with .pack() is fine as it's self-contained) ...
        ctk.CTkButton(toolbar, text="New Map...", command=controller.show_new_map_dialog).pack(pady=10, padx=10, fill="x")
        ctk.CTkLabel(toolbar, text="Level Controls", font=ctk.CTkFont(weight="bold")).pack(pady=(10,0))
        editor_level_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        editor_level_frame.pack(fill="x", padx=10, pady=5)
        self.editor_level_down_btn = ctk.CTkButton(editor_level_frame, text="Down", command=lambda: controller.change_level(-1))
        self.editor_level_down_btn.pack(side="left", expand=True, padx=2)
        self.editor_level_label = ctk.CTkLabel(editor_level_frame, text="Lvl: 0", width=50)
        self.editor_level_label.pack(side="left", expand=True)
        self.editor_level_up_btn = ctk.CTkButton(editor_level_frame, text="Up", command=lambda: controller.change_level(1))
        self.editor_level_up_btn.pack(side="left", expand=True, padx=2)
        ctk.CTkLabel(toolbar, text="Editor Tools", font=ctk.CTkFont(weight="bold")).pack(pady=(10,0))
        ctk.CTkButton(toolbar, text="Brush", command=lambda: controller.set_tool("brush")).pack(pady=5, padx=10, fill="x")
        ctk.CTkButton(toolbar, text="Rectangle", command=lambda: controller.set_tool("rect")).pack(pady=5, padx=10, fill="x")
        self.color_var = ctk.StringVar(value="#999999")
        colors = {"Stone": "#999999", "Grass": "#6B8E23", "Water": "#4682B4", "Wood": "#8B4513"}
        for name, code in colors.items(): ctk.CTkRadioButton(toolbar, text=name, variable=self.color_var, value=code).pack(anchor="w", padx=20, pady=2)
        ctk.CTkLabel(toolbar, text="Landmark Tool", font=ctk.CTkFont(weight="bold")).pack(pady=(20, 5))
        self.landmark_text_entry = ctk.CTkEntry(toolbar, placeholder_text="Landmark Text...")
        self.landmark_text_entry.pack(pady=5, padx=10, fill="x")
        ctk.CTkButton(toolbar, text="Place Landmark", command=lambda: controller.set_tool("landmark")).pack(pady=5, padx=10, fill="x")
        ctk.CTkLabel(toolbar, text="Map Properties", font=ctk.CTkFont(weight="bold")).pack(pady=(20, 5))
        scale_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        scale_frame.pack(fill="x", padx=10, pady=5)
        ctk.CTkLabel(scale_frame, text="Grid Scale (m):").pack(side="left")
        self.scale_entry = ctk.CTkEntry(scale_frame, width=60)
        self.scale_entry.pack(side="left", padx=5)
        ctk.CTkLabel(toolbar, text="Map Name:").pack(anchor="w", padx=10)
        self.map_name_entry = ctk.CTkEntry(toolbar)
        self.map_name_entry.pack(pady=(0,10), padx=10, fill="x")
        ctk.CTkButton(toolbar, text="Save Map", command=controller.save_map).pack(side="bottom", pady=10, padx=10, fill="x")
        
        canvas_container = ctk.CTkScrollableFrame(self.editor_tab, label_text="Map Canvas")
        canvas_container.grid(row=0, column=1, sticky="nsew", padx=10, pady=10)
        
        # --- FIX: Configure the grid inside the scrollable frame ---
        canvas_container.grid_columnconfigure(0, weight=1)
        canvas_container.grid_rowconfigure(0, weight=1)

        self.editor_canvas = ctk.CTkCanvas(canvas_container, bg="#2B2B2B", highlightthickness=0)
        self.editor_canvas.bind("<B1-Motion>", controller.on_editor_canvas_drag)
        self.editor_canvas.bind("<ButtonPress-1>", controller.on_editor_canvas_press)
        self.editor_canvas.bind("<ButtonRelease-1>", controller.on_editor_canvas_release)
        # --- FIX: Use grid to place the canvas ---
        self.editor_canvas.grid(row=0, column=0, sticky="nsew")

    def setup_viewer_ui(self, controller):
        """Builds the UI for the Map Viewer tab."""
        self.viewer_tab.grid_columnconfigure(1, weight=1)
        self.viewer_tab.grid_rowconfigure(0, weight=1)
        
        toolbar = ctk.CTkFrame(self.viewer_tab, width=220)
        toolbar.grid(row=0, column=0, sticky="ns", padx=10, pady=10)
        # ... (Toolbar setup with .pack() is fine) ...
        ctk.CTkLabel(toolbar, text="Select Map:").pack(pady=(10, 5))
        self.map_selection_list = AutoWidthComboBox(toolbar, command=controller.load_map_for_viewing)
        self.map_selection_list.pack(pady=5, padx=10, fill="x")
        self.map_selection_list.bind("<Button-1>", lambda event: self.map_selection_list._open_dropdown_menu())
        ctk.CTkLabel(toolbar, text="Level Controls", font=ctk.CTkFont(weight="bold")).pack(pady=(10,0))
        viewer_level_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        viewer_level_frame.pack(fill="x", padx=10, pady=5)
        self.viewer_level_down_btn = ctk.CTkButton(viewer_level_frame, text="Down", command=lambda: controller.change_level(-1))
        self.viewer_level_down_btn.pack(side="left", expand=True, padx=2)
        self.viewer_level_label = ctk.CTkLabel(viewer_level_frame, text="Lvl: 0", width=50)
        self.viewer_level_label.pack(side="left", expand=True)
        self.viewer_level_up_btn = ctk.CTkButton(viewer_level_frame, text="Up", command=lambda: controller.change_level(1))
        self.viewer_level_up_btn.pack(side="left", expand=True, padx=2)
        ctk.CTkLabel(toolbar, text="Token Tools", font=ctk.CTkFont(weight="bold")).pack(pady=(20, 5))
        self.token_placer_list = AutoWidthComboBox(toolbar, values=["Load characters/npcs"])
        self.token_placer_list.pack(pady=5, padx=10, fill="x")
        ctk.CTkButton(toolbar, text="Place Token", command=lambda: controller.set_tool("place_token")).pack(pady=5, padx=10, fill="x")
        ctk.CTkButton(toolbar, text="Delete Selected", command=controller.delete_selected_tokens, fg_color="#D2691E", hover_color="#B2590E").pack(pady=5, padx=10, fill="x")
        ctk.CTkLabel(toolbar, text="Token Actions", font=ctk.CTkFont(weight="bold")).pack(pady=(20, 5))
        ctk.CTkLabel(toolbar, text="Movement (m):").pack()
        self.movement_entry = ctk.CTkEntry(toolbar, width=80)
        self.movement_entry.pack()
        self.movement_entry.insert(0, "6")
        ctk.CTkLabel(toolbar, text="Distance:").pack(pady=(10, 0))
        self.distance_label = ctk.CTkLabel(toolbar, text="-", font=ctk.CTkFont(size=16, weight="bold"))
        self.distance_label.pack()
        
        canvas_container = ctk.CTkScrollableFrame(self.viewer_tab, label_text="Live Map")
        canvas_container.grid(row=0, column=1, sticky="nsew", padx=10, pady=10)
        
        # --- FIX: Configure the grid inside the scrollable frame ---
        canvas_container.grid_columnconfigure(0, weight=1)
        canvas_container.grid_rowconfigure(0, weight=1)

        self.viewer_canvas = ctk.CTkCanvas(canvas_container, bg="#101010", highlightthickness=0)
        self.viewer_canvas.bind("<Button-1>", controller.on_viewer_canvas_press)
        self.viewer_canvas.bind("<B1-Motion>", controller.on_viewer_canvas_drag)
        self.viewer_canvas.bind("<ButtonRelease-1>", controller.on_viewer_canvas_release)
        self.viewer_canvas.bind("<Control-Button-1>", controller.on_viewer_canvas_ctrl_press)
        # --- FIX: Use grid to place the canvas ---
        self.viewer_canvas.grid(row=0, column=0, sticky="nsew")

    def clear_all_canvases(self):
        self.editor_canvas.delete("all")
        self.editor_canvas.configure(width=1, height=1)
        self.viewer_canvas.delete("all")
        self.viewer_canvas.configure(width=1, height=1)

    def update_level_controls(self, map_model, current_level):
        if map_model and map_model.map_type == 'inside':
            self.editor_level_label.configure(text=f"Lvl: {current_level}")
            self.editor_level_down_btn.configure(state="normal")
            self.editor_level_up_btn.configure(state="normal")
            self.viewer_level_label.configure(text=f"Lvl: {current_level}")
            self.viewer_level_down_btn.configure(state="normal")
            self.viewer_level_up_btn.configure(state="normal")
        else:
            level_text = "Outside" if map_model else "No Map"
            self.editor_level_label.configure(text=level_text)
            self.editor_level_down_btn.configure(state="disabled")
            self.editor_level_up_btn.configure(state="disabled")
            self.viewer_level_label.configure(text=level_text)
            self.viewer_level_down_btn.configure(state="disabled")
            self.viewer_level_up_btn.configure(state="disabled")

    def save_canvas_to_png(self, filepath, map_model, current_level):
        try:
            grid_size = map_model.grid_size
            width = map_model.width * grid_size
            height = map_model.height * grid_size
            image = Image.new("RGB", (width, height), "#2B2B2B")
            draw = ImageDraw.Draw(image)
            for elem in map_model.levels[current_level]['elements']:
                coords = tuple(c * grid_size for c in elem['coords'])
                draw.rectangle(coords, fill=elem['color'], outline=None)
            grid_line_color = "#444444"
            for i in range(0, width, grid_size):
                draw.line([(i, 0), (i, height)], fill=grid_line_color, width=1)
            for i in range(0, height, grid_size):
                draw.line([(0, i), (width, i)], fill=grid_line_color, width=1)
            image.save(filepath)
            return True
        except Exception as e:
            print(f"Error saving canvas to PNG with ImageDraw: {e}")
            return False

    def _draw_grid(self, canvas, width, height, grid_size):
        for i in range(0, width + 1, grid_size):
            canvas.create_line(i, 0, i, height, tag="grid_line", fill="#444444")
        for i in range(0, height + 1, grid_size):
            canvas.create_line(0, i, width, i, tag="grid_line", fill="#444444")

    def _draw_landmarks(self, canvas, map_model, current_level):
        if 'landmarks' not in map_model.levels[current_level]: return
        grid_size = map_model.grid_size
        for landmark in map_model.levels[current_level]['landmarks']:
            x = (landmark['x'] + 0.5) * grid_size
            y = (landmark['y'] + 0.5) * grid_size
            canvas.create_text(x, y, text=landmark['text'], fill="yellow", 
                               font=("Arial", 10, "bold"), anchor="center")

    def draw_editor_canvas(self, map_model, current_level):
        canvas_width = map_model.width * map_model.grid_size
        canvas_height = map_model.height * map_model.grid_size
        self.editor_canvas.configure(width=canvas_width, height=canvas_height)
        self.editor_canvas.delete("all")
        for elem in map_model.levels[current_level]['elements']:
            coords = tuple(c * map_model.grid_size for c in elem['coords'])
            self.editor_canvas.create_rectangle(coords, fill=elem['color'], outline="")
        self._draw_grid(self.editor_canvas, canvas_width, canvas_height, map_model.grid_size)
        self._draw_landmarks(self.editor_canvas, map_model, current_level)

    def draw_viewer_canvas(self, map_model, controller):
        self.viewer_canvas.delete("token", "overlay")
        current_level = controller.current_level
        grid_size = map_model.grid_size
        for token in map_model.levels[current_level]['tokens']:
            if token is not controller.token_being_dragged:
                self._draw_token(self.viewer_canvas, token, grid_size)
        if controller.token_being_dragged and controller.drag_preview_pos:
            self._draw_token(self.viewer_canvas, controller.token_being_dragged, grid_size, preview_pos=controller.drag_preview_pos)
        self._draw_selection_overlay(map_model, controller)

    def _draw_token(self, canvas, token_data, grid_size, preview_pos=None):
        color = self.PC_COLOR if token_data['type'] == 'PC' else self.NPC_COLOR
        center_x, center_y = preview_pos or ((token_data['x'] + 0.5) * grid_size, (token_data['y'] + 0.5) * grid_size)
        radius = grid_size * 0.4
        canvas.create_oval(center_x - radius, center_y - radius, center_x + radius, center_y + radius, fill=color, outline="white", width=1, tags="token")
        canvas.create_text(center_x, center_y, text=token_data['name'][0], fill="white", font=("Arial", 10, "bold"), tags="token")

    def _draw_selection_overlay(self, map_model, controller):
        if not controller.selected_tokens: return
        grid_size = map_model.grid_size
        if len(controller.selected_tokens) == 1:
            token = controller.selected_tokens[0]
            try: move_dist = float(self.movement_entry.get() or 0)
            except ValueError: move_dist = 0
            if move_dist > 0:
                start_pos = controller.drag_start_pos.get(token['name'], (token['x'], token['y']))
                radius = (move_dist / map_model.grid_scale) * grid_size
                center_x, center_y = (start_pos[0] + 0.5) * grid_size, (start_pos[1] + 0.5) * grid_size
                self.viewer_canvas.create_oval(center_x - radius, center_y - radius, center_x + radius, center_y + radius, outline="yellow", dash=(4, 4), width=2, tags="overlay")
        elif len(controller.selected_tokens) == 2:
            t1, t2 = controller.selected_tokens[0], controller.selected_tokens[1]
            x1, y1 = (t1['x'] + 0.5) * grid_size, (t1['y'] + 0.5) * grid_size
            x2, y2 = (t2['x'] + 0.5) * grid_size, (t2['y'] + 0.5) * grid_size
            self.viewer_canvas.create_line(x1, y1, x2, y2, fill="yellow", width=2, dash=(4, 4), tags="overlay")

    def update_token_placer_list(self, tokens):
        values = tokens or ["Load characters/npcs"]
        self.token_placer_list.configure(values=values)
        if tokens: self.token_placer_list.set(values[0])
        else: self.token_placer_list.set("Load characters/npcs")

    def update_map_list(self, maps):
        prompt = "Select a saved map..."
        display_values = [prompt] + (maps or [])
        self.map_selection_list.configure(values=display_values)
        self.map_selection_list.set(prompt)

    def draw_static_background(self, map_model, current_level):
        canvas_width = map_model.width * map_model.grid_size
        canvas_height = map_model.height * map_model.grid_size
        self.viewer_canvas.configure(width=canvas_width, height=canvas_height)
        self.viewer_canvas.delete("all")
        if not map_model: return
        for elem in map_model.levels[current_level]['elements']:
            coords = tuple(c * map_model.grid_size for c in elem['coords'])
            self.viewer_canvas.create_rectangle(coords, fill=elem['color'], outline="")
        self._draw_grid(self.viewer_canvas, canvas_width, canvas_height, map_model.grid_size)
        self._draw_landmarks(self.viewer_canvas, map_model, current_level)

    def update_dimension_fields(self, map_model):
        self.scale_entry.delete(0, 'end')
        self.scale_entry.insert(0, str(map_model.grid_scale))

================================================================================
--- FILE: map/map_generation/map_generation_controller.py ---
================================================================================

from .map_generation_view import MapGenerationDialog
from .map_generation_model import MapGenerationModel
from custom_dialogs import MessageBox # Ensure you have this file

class MapGenerationController:
    """Orchestrates the map generation process."""
    def __init__(self, parent_view):
        self.parent_view = parent_view
        self.model = MapGenerationModel()
        self.generated_data = None

    def show_generation_dialog(self):
        """Shows the generation dialog and returns the generated map data."""
        dialog = MapGenerationDialog(self.parent_view, self)
        user_input = dialog.get_result()

        if user_input:
            gen_type = user_input["gen_type"]
            settings = user_input["settings"]
            
            # Call the model to get the map data
            self.generated_data = self.model.generate(gen_type, settings)
            
            # Attach the common settings to the top level of the data
            self.generated_data['width'] = settings['width']
            self.generated_data['height'] = settings['height']
            self.generated_data['grid_scale'] = settings['grid_scale']
            
            return self.generated_data
        
        return None

================================================================================
--- FILE: map/map_generation/map_generation_model.py ---
================================================================================

import random
import heapq

class MapGenerationModel:
    # ... (generate, _get_base_map_data, generate_blank_map are unchanged) ...
    def generate(self, gen_type, settings):
        if gen_type == "Dungeon":
            return self.generate_dungeon(settings)
        elif gen_type == "Winding Road":
            return self.generate_winding_road(settings)
        elif gen_type == "Simple Town":
            layout = settings.get("town_layout", "Crossroads")
            if layout == "Main Street":
                return self._generate_main_street_town(settings)
            elif layout == "Riverside":
                return self._generate_riverside_town(settings)
            else:
                return self._generate_crossroads_town(settings)
        else:
            return self.generate_blank_map(settings)
    def _get_base_map_data(self, settings, map_type='outside', bg_color='#6B8E23'):
        width = settings.get('width', 50)
        height = settings.get('height', 50)
        return {
            'width': width, 'height': height, 'grid_scale': settings.get('grid_scale', 1.5),
            'map_type': map_type,
            'levels': { 0: { 'elements': [{'type': 'rect', 'coords': (0, 0, width, height), 'color': bg_color}], 'tokens': [], 'landmarks': [] } }
        }
    def generate_blank_map(self, settings):
        return self._get_base_map_data(settings, bg_color='#2B2B2B')

    def generate_dungeon(self, settings):
        map_data = self._get_base_map_data(settings, map_type='inside', bg_color='#2B2B2B')
        elements, landmarks = map_data['levels'][0]['elements'], map_data['levels'][0]['landmarks']
        width, height = map_data['width'], map_data['height']
        
        num_rooms = settings.get("dungeon_rooms", 30)
        min_size = settings.get("dungeon_min_size", 5)
        max_size = settings.get("dungeon_max_size", 12)

        rooms = []
        for _ in range(num_rooms * 3):
            if len(rooms) >= num_rooms: break
            w, h = random.randint(min_size, max_size), random.randint(min_size, max_size)
            x, y = random.randint(1, width - w - 2), random.randint(1, height - h - 2)
            new_room = {'x1': x, 'y1': y, 'x2': x + w, 'y2': y + h}
            if any(self._intersect(new_room, other, padding=2) for other in rooms): continue
            
            elements.append({'type': 'rect', 'coords': (new_room['x1'], new_room['y1'], new_room['x2'], new_room['y2']), 'color': '#707070'})
            if rooms:
                prev_center = ((rooms[-1]['x1'] + rooms[-1]['x2']) // 2, (rooms[-1]['y1'] + rooms[-1]['y2']) // 2)
                new_center = ((new_room['x1'] + new_room['x2']) // 2, (new_room['y1'] + new_room['y2']) // 2)
                # --- FIX: Pass the list of rooms as obstacles ---
                self._create_corridor(elements, prev_center, new_center, obstacles=rooms)
            rooms.append(new_room)
            
        if rooms:
            landmarks.append({'x': (rooms[0]['x1']+rooms[0]['x2'])//2, 'y': (rooms[0]['y1']+rooms[0]['y2'])//2, 'text': 'Entrance'})
            if len(rooms) > 1:
                landmarks.append({'x': (rooms[-1]['x1']+rooms[-1]['x2'])//2, 'y': (rooms[-1]['y1']+rooms[-1]['y2'])//2, 'text': 'Treasure'})
        return map_data

    def generate_winding_road(self, settings):
        map_data = self._get_base_map_data(settings, bg_color='#228B22')
        elements, landmarks = map_data['levels'][0]['elements'], map_data['levels'][0]['landmarks']
        width, height = map_data['width'], map_data['height']
        
        path_width = settings.get("road_path_width", 3)
        scenery_density = settings.get("road_scenery_density", 70)

        y = height // 2
        path_elements = []
        for x in range(width):
            path_rect = {'type': 'rect', 'coords': (x, y - path_width//2, x + 1, y + path_width//2 + 1), 'color': '#D2B48C'}
            elements.append(path_rect)
            path_elements.append(path_rect)
            y += random.randint(-1, 1)
            y = max(path_width, min(y, height - path_width))
        for _ in range(scenery_density):
            px, py = random.randint(0, width-1), random.randint(0, height-1)
            point_rect = {'x1':px, 'y1':py, 'x2':px+1, 'y2':py+1}
            if not any(self._intersect(point_rect, path_elem) for path_elem in path_elements):
                elements.append({'type': 'rect', 'coords': (px, py, px+1, py+1), 'color': '#696969'})
        landmarks.append({'x': 1, 'y': height//2, 'text': 'Start'})
        landmarks.append({'x': width-2, 'y': y, 'text': 'End'})
        landmarks.append({'x': width//2, 'y': height - 5, 'text': 'Cave'})
        return map_data

    def _generate_crossroads_town(self, settings):
        map_data = self._get_base_map_data(settings, bg_color='#6B8E23')
        elements, landmarks = map_data['levels'][0]['elements'], map_data['levels'][0]['landmarks']
        width, height = map_data['width'], map_data['height']
        road_color, path_color, bld_color = '#D2B48C', '#BC8F8F', '#8B4513'
        num_buildings = settings.get("town_buildings", 15)
        h_road_y, v_road_x = height // 2, width // 2
        road_w, square_s = 2, random.randint(4, 6)
        no_build_zones = []
        roads = [
            {'x1': 0, 'y1': h_road_y - road_w//2, 'x2': v_road_x - square_s, 'y2': h_road_y + road_w//2},
            {'x1': v_road_x + square_s, 'y1': h_road_y - road_w//2, 'x2': width, 'y2': h_road_y + road_w//2},
            {'x1': v_road_x - road_w//2, 'y1': 0, 'x2': v_road_x + road_w//2, 'y2': h_road_y - square_s},
            {'x1': v_road_x - road_w//2, 'y1': h_road_y + square_s, 'x2': v_road_x + road_w//2, 'y2': height},
            {'x1': v_road_x - square_s, 'y1': h_road_y - square_s, 'x2': v_road_x + square_s, 'y2': h_road_y + square_s}
        ]
        no_build_zones.extend(roads)
        for road in roads: elements.append({'type': 'rect', 'coords': (road['x1'], road['y1'], road['x2'], road['y2']), 'color': road_color})
        buildings = self._place_buildings(width, height, no_build_zones, num_buildings, num_buildings)
        for b in buildings:
            elements.append({'type': 'rect', 'coords': (b['x1'], b['y1'], b['x2'], b['y2']), 'color': bld_color})
            door_pos = self._find_door_location(b, v_road_x, h_road_y)
            self._create_path_to_road(elements, door_pos, v_road_x, h_road_y, path_color, buildings)
        landmarks.extend([{'x': v_road_x, 'y': h_road_y, 'text': 'Town Square'}, {'x': v_road_x + 2, 'y': h_road_y + 2, 'text': 'Fountain'}])
        return map_data

    def _generate_main_street_town(self, settings):
        map_data = self._get_base_map_data(settings, bg_color='#6B8E23')
        elements, landmarks = map_data['levels'][0]['elements'], map_data['levels'][0]['landmarks']
        width, height = map_data['width'], map_data['height']
        road_color, path_color, bld_color = '#D2B48C', '#BC8F8F', '#8B4513'
        num_buildings = settings.get("town_buildings", 15)
        road_pos, road_w = width // 2, 3
        road = {'x1': road_pos - road_w//2, 'y1': 0, 'x2': road_pos + road_w//2 + 1, 'y2': height}
        no_build_zones = [road]
        elements.append({'type': 'rect', 'coords': (road['x1'], road['y1'], road['x2'], road['y2']), 'color': road_color})
        buildings = self._place_buildings(width, height, no_build_zones, num_buildings, num_buildings)
        for b in buildings:
            elements.append({'type': 'rect', 'coords': (b['x1'], b['y1'], b['x2'], b['y2']), 'color': bld_color})
            door_pos = self._find_door_location(b, road_pos, None)
            self._create_path_to_road(elements, door_pos, road_pos, None, path_color, buildings)
        landmarks.extend([{'x': road_pos, 'y': 5, 'text': 'North Gate'}, {'x': road_pos, 'y': height - 5, 'text': 'South Gate'}])
        return map_data

    def _generate_riverside_town(self, settings):
        map_data = self._get_base_map_data(settings, bg_color='#6B8E23')
        elements, landmarks = map_data['levels'][0]['elements'], map_data['levels'][0]['landmarks']
        width, height = map_data['width'], map_data['height']
        river_color, path_color, bld_color, wood_color = '#4682B4', '#BC8F8F', '#8B4513', '#A0522D'
        num_buildings = settings.get("town_buildings", 10)
        no_build_zones = []
        river_x, river_w = width // 3, 5
        y = 0
        while y < height:
            river_segment = {'x1': river_x - river_w, 'y1': y, 'x2': river_x + river_w, 'y2': y + 1}
            elements.append({'type': 'rect', 'coords': (river_segment['x1'], river_segment['y1'], river_segment['x2'], river_segment['y2']), 'color': river_color})
            no_build_zones.append(river_segment)
            river_x += random.randint(-1, 1)
            river_x = max(river_w + 1, min(river_x, width - river_w - 1))
            y += 1
        bridge_y = height // 2
        bridge = {'x1': 0, 'y1': bridge_y, 'x2': width, 'y2': bridge_y + 2}
        no_build_zones.append(bridge)
        elements.append({'type': 'rect', 'coords': (bridge['x1'], bridge['y1'], bridge['x2'], bridge['y2']), 'color': wood_color})
        landmarks.append({'x': river_x, 'y': bridge_y, 'text': 'Bridge'})
        buildings = self._place_buildings(width, height, no_build_zones, num_buildings, num_buildings, safe_zone_x_min=river_x + river_w)
        for b in buildings:
            elements.append({'type': 'rect', 'coords': (b['x1'], b['y1'], b['x2'], b['y2']), 'color': bld_color})
            door_pos = self._find_door_location(b, None, bridge_y)
            self._create_path_to_road(elements, door_pos, None, bridge_y, path_color, buildings)
        landmarks.append({'x': river_x + 8, 'y': bridge_y + 8, 'text': 'Ferry Dock'})
        return map_data

    def _place_buildings(self, width, height, no_build_zones, min_bld, max_bld, safe_zone_x_min=1):
        buildings = []
        for _ in range(random.randint(min_bld, max_bld)):
            w, h = random.randint(4, 9), random.randint(4, 9)
            for _ in range(50):
                x = random.randint(safe_zone_x_min, width - w - 1)
                y = random.randint(1, height - h - 1)
                new_b = {'x1': x, 'y1': y, 'x2': x + w, 'y2': y + h}
                if not any(self._intersect(new_b, b, padding=2) for b in buildings) and \
                   not any(self._intersect(new_b, z) for z in no_build_zones):
                    buildings.append(new_b)
                    break
        return buildings

    def _find_door_location(self, building, v_road_x, h_road_y):
        dist_v, dist_h = float('inf'), float('inf')
        if v_road_x is not None:
            dist_v = min(abs(building['x1'] - v_road_x), abs(building['x2'] - v_road_x))
        if h_road_y is not None:
            dist_h = min(abs(building['y1'] - h_road_y), abs(building['y2'] - h_road_y))
        door_y = random.randint(building['y1'] + 1, building['y2'] - 2)
        door_x = random.randint(building['x1'] + 1, building['x2'] - 2)
        if dist_v < dist_h:
            if abs(building['x1'] - v_road_x) < abs(building['x2'] - v_road_x): return (building['x1'], door_y)
            else: return (building['x2'], door_y)
        else:
            if abs(building['y1'] - h_road_y) < abs(building['y2'] - h_road_y): return (door_x, building['y1'])
            else: return (door_x, building['y2'])

    def _create_path_to_road(self, elements, door_pos, v_road_x, h_road_y, color, obstacles):
        x1, y1 = door_pos
        if v_road_x is not None and (h_road_y is None or abs(x1 - v_road_x) < abs(y1 - h_road_y)):
            x2, y2 = v_road_x, y1
        elif h_road_y is not None:
            x2, y2 = x1, h_road_y
        else: return
        path = self._astar_pathfind((x1, y1), (x2, y2), obstacles)
        if path:
            for point in path:
                elements.append({'type': 'rect', 'coords': (point[0], point[1], point[0] + 1, point[1] + 1), 'color': color})

    def _intersect(self, r1, r2, padding=0):
        r2_x1, r2_y1, r2_x2, r2_y2 = r2.get('x1'), r2.get('y1'), r2.get('x2'), r2.get('y2')
        if 'coords' in r2:
            r2_x1, r2_y1, r2_x2, r2_y2 = r2['coords']
        return (r1['x1'] < r2_x2 + padding and r1['x2'] + padding > r2_x1 and
                r1['y1'] < r2_y2 + padding and r1['y2'] + padding > r2_y1)

    def _create_corridor(self, elements, p1, p2, obstacles=[], color='#707070', width=1):
        path = self._astar_pathfind(p1, p2, obstacles)
        if path:
            for point in path:
                elements.append({'type': 'rect', 'coords': (point[0], point[1], point[0] + width, point[1] + width), 'color': color})

    def _astar_pathfind(self, start, end, obstacles):
        open_set_heap = []
        heapq.heappush(open_set_heap, (0, start))
        open_set_hash = {start}
        came_from = {}
        g_score = {start: 0}
        f_score = {start: abs(start[0] - end[0]) + abs(start[1] - end[1])}
        obstacle_map = set()
        for obs in obstacles:
            for x in range(obs['x1'], obs['x2']):
                for y in range(obs['y1'], obs['y2']):
                    obstacle_map.add((x, y))
        while open_set_heap:
            _, current = heapq.heappop(open_set_heap)
            open_set_hash.remove(current)
            if current == end:
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                return path
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                neighbor = (current[0] + dx, current[1] + dy)
                if neighbor in obstacle_map:
                    continue
                tentative_g_score = g_score[current] + 1
                if tentative_g_score < g_score.get(neighbor, float('inf')):
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])
                    if neighbor not in open_set_hash:
                        heapq.heappush(open_set_heap, (f_score[neighbor], neighbor))
                        open_set_hash.add(neighbor)
        return None

================================================================================
--- FILE: map/map_generation/map_generation_view.py ---
================================================================================

import customtkinter as ctk
from custom_dialogs import MessageBox

class MapGenerationDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        self.result = None

        self.title("New Map Generator")
        self.geometry("450x550") # Increased height for new options
        self.resizable(False, False)
        self.configure(fg_color="#2B2B2B")
        self.protocol("WM_DELETE_WINDOW", self._on_cancel)

        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(padx=20, pady=20, fill="both", expand=True)

        ctk.CTkLabel(main_frame, text="Generate a New Map", font=ctk.CTkFont(size=18, weight="bold")).pack(pady=(0, 10))

        # --- REFACTORED: Add a command to the generator combo box ---
        ctk.CTkLabel(main_frame, text="Generator Type:", anchor="w").pack(fill="x")
        self.gen_type_combo = ctk.CTkComboBox(
            main_frame, 
            values=["Blank Map", "Dungeon", "Winding Road", "Simple Town"], 
            state="readonly",
            command=self._on_generator_selected # This is the key change
        )
        self.gen_type_combo.pack(fill="x", pady=(0, 15))
        self.gen_type_combo.set("Blank Map")

        # --- Generic Settings (always visible) ---
        generic_settings_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        generic_settings_frame.pack(fill="x", pady=5)
        generic_settings_frame.grid_columnconfigure((1, 3), weight=1)
        ctk.CTkLabel(generic_settings_frame, text="Width:").grid(row=0, column=0, padx=5, pady=5)
        self.width_entry = ctk.CTkEntry(generic_settings_frame)
        self.width_entry.grid(row=0, column=1, sticky="ew", padx=5)
        self.width_entry.insert(0, "50")
        ctk.CTkLabel(generic_settings_frame, text="Height:").grid(row=0, column=2, padx=5, pady=5)
        self.height_entry = ctk.CTkEntry(generic_settings_frame)
        self.height_entry.grid(row=0, column=3, sticky="ew", padx=5)
        self.height_entry.insert(0, "50")
        ctk.CTkLabel(generic_settings_frame, text="Grid Scale (m):").grid(row=1, column=0, padx=5, pady=5)
        self.scale_entry = ctk.CTkEntry(generic_settings_frame)
        self.scale_entry.grid(row=1, column=1, columnspan=3, sticky="ew", padx=5)
        self.scale_entry.insert(0, "1.5")

        # --- NEW: Container for generator-specific settings ---
        self.specific_settings_container = ctk.CTkFrame(main_frame, fg_color="gray20")
        self.specific_settings_container.pack(fill="both", expand=True, pady=10)
        
        # --- NEW: Create frames for each generator type ---
        self._create_dungeon_settings()
        self._create_road_settings()
        self._create_town_settings()

        # Action Buttons
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(side="bottom", pady=(10, 0))
        ctk.CTkButton(button_frame, text="Generate Map", command=self._on_generate).pack(side="left", padx=10)
        ctk.CTkButton(button_frame, text="Cancel", command=self._on_cancel, fg_color="gray50").pack(side="left", padx=10)

        # Show the initial correct settings
        self._on_generator_selected("Blank Map")

        self.transient(parent)
        self.update_idletasks()
        self.grab_set()
        self.wait_window()

    def _create_dungeon_settings(self):
        self.dungeon_frame = ctk.CTkFrame(self.specific_settings_container, fg_color="transparent")
        self.dungeon_frame.pack(fill="both", expand=True, padx=10, pady=10)
        # Num Rooms
        ctk.CTkLabel(self.dungeon_frame, text="Number of Rooms:").pack(anchor="w")
        self.dungeon_rooms_slider = ctk.CTkSlider(self.dungeon_frame, from_=5, to=50, number_of_steps=45)
        self.dungeon_rooms_slider.set(30)
        self.dungeon_rooms_slider.pack(fill="x", pady=(0,10))
        # Room Size
        ctk.CTkLabel(self.dungeon_frame, text="Room Size (Min/Max):").pack(anchor="w")
        size_frame = ctk.CTkFrame(self.dungeon_frame, fg_color="transparent")
        size_frame.pack(fill="x")
        self.dungeon_min_size_slider = ctk.CTkSlider(size_frame, from_=3, to=10, number_of_steps=7)
        self.dungeon_min_size_slider.set(5)
        self.dungeon_min_size_slider.pack(side="left", fill="x", expand=True, padx=(0,5))
        self.dungeon_max_size_slider = ctk.CTkSlider(size_frame, from_=8, to=20, number_of_steps=12)
        self.dungeon_max_size_slider.set(12)
        self.dungeon_max_size_slider.pack(side="left", fill="x", expand=True, padx=(5,0))

    def _create_road_settings(self):
        self.road_frame = ctk.CTkFrame(self.specific_settings_container, fg_color="transparent")
        self.road_frame.pack(fill="both", expand=True, padx=10, pady=10)
        # Path Width
        ctk.CTkLabel(self.road_frame, text="Path Width:").pack(anchor="w")
        self.road_width_slider = ctk.CTkSlider(self.road_frame, from_=1, to=5, number_of_steps=4)
        self.road_width_slider.set(3)
        self.road_width_slider.pack(fill="x", pady=(0,10))
        # Scenery Density
        ctk.CTkLabel(self.road_frame, text="Scenery Density:").pack(anchor="w")
        self.road_scenery_slider = ctk.CTkSlider(self.road_frame, from_=10, to=200, number_of_steps=19)
        self.road_scenery_slider.set(70)
        self.road_scenery_slider.pack(fill="x", pady=(0,10))

    def _create_town_settings(self):
        self.town_frame = ctk.CTkFrame(self.specific_settings_container, fg_color="transparent")
        self.town_frame.pack(fill="both", expand=True, padx=10, pady=10)
        # Layout Type
        ctk.CTkLabel(self.town_frame, text="Road Layout:").pack(anchor="w")
        self.town_layout_combo = ctk.CTkComboBox(self.town_frame, values=["Crossroads", "Main Street", "Riverside"], state="readonly")
        self.town_layout_combo.set("Crossroads")
        self.town_layout_combo.pack(fill="x", pady=(0,10))
        # Building Count
        ctk.CTkLabel(self.town_frame, text="Number of Buildings:").pack(anchor="w")
        self.town_buildings_slider = ctk.CTkSlider(self.town_frame, from_=5, to=25, number_of_steps=20)
        self.town_buildings_slider.set(15)
        self.town_buildings_slider.pack(fill="x", pady=(0,10))

    def _on_generator_selected(self, selection):
        """Hides all specific settings frames and shows the correct one."""
        self.dungeon_frame.pack_forget()
        self.road_frame.pack_forget()
        self.town_frame.pack_forget()
        
        if selection == "Dungeon":
            self.dungeon_frame.pack(fill="both", expand=True, padx=10, pady=10)
        elif selection == "Winding Road":
            self.road_frame.pack(fill="both", expand=True, padx=10, pady=10)
        elif selection == "Simple Town":
            self.town_frame.pack(fill="both", expand=True, padx=10, pady=10)

    def _on_generate(self):
        try:
            settings = {
                "width": int(self.width_entry.get()),
                "height": int(self.height_entry.get()),
                "grid_scale": float(self.scale_entry.get())
            }
            gen_type = self.gen_type_combo.get()
            
            # --- NEW: Add the specific settings based on generator type ---
            if gen_type == "Dungeon":
                settings["dungeon_rooms"] = int(self.dungeon_rooms_slider.get())
                settings["dungeon_min_size"] = int(self.dungeon_min_size_slider.get())
                settings["dungeon_max_size"] = int(self.dungeon_max_size_slider.get())
            elif gen_type == "Winding Road":
                settings["road_path_width"] = int(self.road_width_slider.get())
                settings["road_scenery_density"] = int(self.road_scenery_slider.get())
            elif gen_type == "Simple Town":
                settings["town_layout"] = self.town_layout_combo.get()
                settings["town_buildings"] = int(self.town_buildings_slider.get())

            self.result = { "gen_type": gen_type, "settings": settings }
            self.grab_release()
            self.destroy()
        except ValueError:
            MessageBox.showerror("Invalid Input", "Please ensure width, height, and scale are valid numbers.", parent=self)

    def _on_cancel(self):
        self.result = None
        self.grab_release()
        self.destroy()

    def get_result(self):
        return self.result

================================================================================
--- FILE: quest/quest_controller.py ---
================================================================================

import customtkinter as ctk
from .quest_model import QuestModel
from .quest_view import QuestView, LinkSelectionDialog
from custom_dialogs import MessageBox
from character.character_model import CharacterModel
from npc.npc_model import NpcModel
from item.item_controller import ItemController

class QuestController:
    def __init__(self, app_controller, parent_frame, campaign_path):
        self.app_controller = app_controller
        self.model = QuestModel(campaign_path)
        self.view = QuestView(parent_frame)
        self.view.setup_ui(self)
        self.campaign_path = campaign_path
        self.all_quests = []
        self.selected_quest = None
        
        # --- LAZY LOAD: Load data when controller is created ---
        self.load_all_quests()

    def get_all_quests(self):
        """A simple getter for other controllers to access quest data."""
        return self.all_quests

    def load_all_quests(self):
        # --- MODIFIED: No longer checks cache, it's the source of truth now ---
        self.all_quests = self.model.load_all_quests()
        self.app_controller.set_cached_data('quests', self.all_quests)

        quests_by_status = {"Active": [], "Inactive": [], "Completed": [], "Failed": []}
        for quest in self.all_quests:
            status = quest.get('status', 'Inactive')
            if status in quests_by_status:
                quests_by_status[status].append(quest)
            else:
                quests_by_status["Inactive"].append(quest)
        self.view.display_quest_list(quests_by_status, self)
        if self.selected_quest:
            self.view.highlight_selected_quest(self.selected_quest['id'])
        else:
            self.view.highlight_selected_quest(None)
            self.view.clear_editor()

    def create_new_quest(self):
        dialog = ctk.CTkInputDialog(text="Enter the name for the new quest:", title="New Quest")
        title = dialog.get_input()
        if not title: return
        new_quest = self.model.create_quest(title)
        self.model.save_quest(new_quest)
        self.load_all_quests()
        self.select_quest(new_quest)

    def select_quest(self, quest):
        self.selected_quest = quest
        
        if not self.view.editor_is_built:
            self.view.build_quest_editor(self)
        self.view.populate_editor(quest)
        self.redraw_all_dynamic_content()
        self.view.highlight_selected_quest(quest['id'])

    def redraw_all_dynamic_content(self):
        if not self.selected_quest: return
        self.view.redraw_objectives(self.selected_quest['objectives'], self)
        self.redraw_links()
    
    def save_changes(self):
        if not self.selected_quest: return
        
        original_title = self.selected_quest['title']
        original_status = self.selected_quest['status']

        self.selected_quest['title'] = self.view.title_entry.get()
        self.selected_quest['status'] = self.view.status_combo.get()
        self.selected_quest['description'] = self.view.desc_text.get("1.0", "end-1c")
        
        self.model.save_quest(self.selected_quest)
        
        if original_title != self.selected_quest['title'] or original_status != self.selected_quest['status']:
            self.load_all_quests()
        else:
            # Refresh the all_quests list in memory without a full UI rebuild
            for i, q in enumerate(self.all_quests):
                if q['id'] == self.selected_quest['id']:
                    self.all_quests[i] = self.selected_quest
                    break

        MessageBox.showinfo("Success", "Quest changes have been saved.", self.view.frame)

    def delete_quest(self):
        if not self.selected_quest: return
        if MessageBox.askyesno("Confirm Deletion", f"Are you sure you want to permanently delete '{self.selected_quest['title']}'?", self.view.frame):
            self.model.delete_quest(self.selected_quest['id'])
            self.selected_quest = None
            self.load_all_quests()
            self.view.clear_editor()

    def add_objective(self):
        if not self.selected_quest: return
        self.selected_quest['objectives'].append({"text": "New Objective", "completed": False})
        self.view.redraw_objectives(self.selected_quest['objectives'], self)

    def remove_objective(self, index):
        if not self.selected_quest: return
        self.selected_quest['objectives'].pop(index)
        self.view.redraw_objectives(self.selected_quest['objectives'], self)
    
    def toggle_objective(self, index):
        if not self.selected_quest: return
        self.selected_quest['objectives'][index]['completed'] = not self.selected_quest['objectives'][index]['completed']
    
    def update_objective_text(self, index, new_text):
        if not self.selected_quest: return
        self.selected_quest['objectives'][index]['text'] = new_text

    def redraw_links(self):
        item_controller = self.app_controller.get_loaded_controller(ItemController)
        all_npcs_data = []
        if self.app_controller.ruleset_data:
            npc_names = NpcModel.get_for_ruleset(self.campaign_path, self.app_controller.ruleset_data['name'])
            all_npcs_data = [npc.to_dict() for npc in [NpcModel.load(self.campaign_path, name) for name in npc_names] if npc]
            for npc in all_npcs_data:
                npc['id'] = npc['name']
        
        all_items_data = item_controller.all_items if item_controller else []
        self.view.redraw_links(self.selected_quest['linked_npcs'], self.selected_quest['linked_items'], all_npcs_data, all_items_data, self)

    def show_add_npc_dialog(self):
        if not self.app_controller.ruleset_data: return
        all_npcs_data = [npc.to_dict() for npc in [NpcModel.load(self.campaign_path, name) for name in NpcModel.get_for_ruleset(self.campaign_path, self.app_controller.ruleset_data['name'])] if npc]
        for npc in all_npcs_data: npc['id'] = npc['name']
        dialog = LinkSelectionDialog(self.view.frame, "Link NPC", all_npcs_data)
        npc_id = dialog.get_selection()
        if npc_id and npc_id not in self.selected_quest['linked_npcs']:
            self.selected_quest['linked_npcs'].append(npc_id)
            self.redraw_links()

    def show_add_item_dialog(self):
        item_controller = self.app_controller.get_loaded_controller(ItemController)
        if not item_controller: return
        dialog = LinkSelectionDialog(self.view.frame, "Link Item", item_controller.all_items)
        item_id = dialog.get_selection()
        if item_id and item_id not in self.selected_quest['linked_items']:
            self.selected_quest['linked_items'].append(item_id)
            self.redraw_links()

    def remove_link(self, link_type, item_id):
        if not self.selected_quest: return
        if link_type == "npc":
            self.selected_quest['linked_npcs'].remove(item_id)
        elif link_type == "item":
            self.selected_quest['linked_items'].remove(item_id)
        self.redraw_links()

================================================================================
--- FILE: quest/quest_model.py ---
================================================================================

import json
import uuid
from database import Database

class QuestModel:
    """Manages the quest database for a specific campaign."""
    def __init__(self, campaign_path):
        self.db = Database(self.campaign_path)

    def load_all_quests(self):
        """Loads the entire list of quests from the database."""
        self.db.connect()
        rows = self.db.fetchall("SELECT data FROM quests")
        self.db.close()
        if not rows:
            return []
        try:
            return [json.loads(row['data']) for row in rows]
        except json.JSONDecodeError:
            return []

    def save_quest(self, quest_data):
        """Saves a single quest to the database."""
        self.db.connect()
        self.db.execute(
            "INSERT OR REPLACE INTO quests (id, data) VALUES (?, ?)",
            (quest_data['id'], json.dumps(quest_data))
        )
        self.db.close()

    def delete_quest(self, quest_id):
        """Deletes a single quest from the database."""
        self.db.connect()
        self.db.execute("DELETE FROM quests WHERE id = ?", (quest_id,))
        self.db.close()

    def create_quest(self, title):
        """Creates a new quest dictionary with default values."""
        return {
            "id": str(uuid.uuid4()),
            "title": title,
            # --- FIX: New quests are now "Inactive" by default ---
            "status": "Inactive",
            "description": "",
            "objectives": [],
            "linked_npcs": [],
            "linked_items": []
        }

================================================================================
--- FILE: quest/quest_view.py ---
================================================================================

import customtkinter as ctk

class LinkSelectionDialog(ctk.CTkToplevel):
    """A reusable dialog to select an NPC or Item to link to a quest."""
    def __init__(self, parent, title, items_to_display):
        super().__init__(parent)
        self.title(title)
        self.geometry("400x500")
        self.configure(fg_color="#2B2B2B")
        self.protocol("WM_DELETE_WINDOW", self._on_cancel)
        self.selected_id = None
        self.buttons = []
        ctk.CTkLabel(self, text=f"Select {title.split(' ')[-1]} to Link", font=ctk.CTkFont(size=16)).pack(pady=10)
        scroll_frame = ctk.CTkScrollableFrame(self)
        scroll_frame.pack(fill="both", expand=True, padx=10, pady=5)
        if not items_to_display:
            ctk.CTkLabel(scroll_frame, text="Nothing available to link.").pack()
        else:
            for item in items_to_display:
                btn = ctk.CTkButton(scroll_frame, text=item["name"],
                                    command=lambda i=item: self._select(i), 
                                    fg_color="transparent", anchor="w", border_width=1, border_color="gray50")
                btn.pack(fill="x", pady=2)
                self.buttons.append((btn, item))
        self.confirm_button = ctk.CTkButton(self, text="Link Selected", command=self._on_confirm, state="disabled")
        self.confirm_button.pack(pady=10)
        self.transient(parent)
        self.update_idletasks()
        self.grab_set()
        self.wait_window()

    def _select(self, item):
        self.selected_id = item["id"]
        self.confirm_button.configure(state="normal")
        for btn, btn_item in self.buttons:
            if btn_item["id"] == item["id"]:
                btn.configure(fg_color="#3B8ED0", border_color="#3B8ED0")
            else:
                btn.configure(fg_color="transparent", border_color="gray50")

    def _on_confirm(self):
        self.destroy()

    def _on_cancel(self):
        self.selected_id = None
        self.destroy()

    def get_selection(self):
        return self.selected_id

class QuestView:
    def __init__(self, parent_frame):
        self.frame = parent_frame
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_columnconfigure(1, weight=2)
        self.frame.grid_rowconfigure(0, weight=1)
        self.quest_buttons = {}
        self.editor_is_built = False

    def setup_ui(self, controller):
        list_frame = ctk.CTkFrame(self.frame)
        list_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        list_frame.grid_rowconfigure(1, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)
        ctk.CTkButton(list_frame, text="Create New Quest", command=controller.create_new_quest).grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        self.quest_list_scroll_frame = ctk.CTkScrollableFrame(list_frame, label_text="Quests by Status")
        self.quest_list_scroll_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        
        self.editor_frame = ctk.CTkFrame(self.frame, fg_color="transparent")
        self.editor_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        self.editor_frame.grid_columnconfigure(0, weight=1)
        self.editor_frame.grid_rowconfigure(0, weight=1)

    def build_quest_editor(self, controller):
        """Builds the editor UI widgets ONCE."""
        if self.editor_is_built: return
        for widget in self.editor_frame.winfo_children():
            widget.destroy()
        self.editor_frame.grid_columnconfigure(1, weight=1)
        self.editor_frame.grid_rowconfigure(3, weight=1)
        self.editor_frame.grid_rowconfigure(5, weight=1)
        self.editor_label = ctk.CTkLabel(self.editor_frame, text="Create New Item", font=ctk.CTkFont(size=16, weight="bold"))
        self.editor_label.grid(row=0, column=0, columnspan=2, pady=10, padx=10)
        ctk.CTkLabel(self.editor_frame, text="Title:").grid(row=1, column=0, padx=10, sticky="w")
        self.title_entry = ctk.CTkEntry(self.editor_frame)
        self.title_entry.grid(row=1, column=1, padx=10, pady=5, sticky="ew")
        ctk.CTkLabel(self.editor_frame, text="Status:").grid(row=2, column=0, padx=10, sticky="w")
        self.status_combo = ctk.CTkComboBox(self.editor_frame, values=["Active", "Inactive", "Completed", "Failed"])
        self.status_combo.grid(row=2, column=1, padx=10, pady=5, sticky="ew")
        ctk.CTkLabel(self.editor_frame, text="Description:").grid(row=3, column=0, padx=10, sticky="nw")
        self.desc_text = ctk.CTkTextbox(self.editor_frame)
        self.desc_text.grid(row=3, column=1, padx=10, pady=5, sticky="nsew")
        obj_frame = ctk.CTkFrame(self.editor_frame)
        obj_frame.grid(row=4, column=0, columnspan=2, padx=10, pady=5, sticky="nsew")
        obj_frame.grid_columnconfigure(0, weight=1)
        ctk.CTkLabel(obj_frame, text="Objectives").pack(side="left")
        ctk.CTkButton(obj_frame, text="+", width=30, command=controller.add_objective).pack(side="right")
        self.objectives_frame = ctk.CTkScrollableFrame(self.editor_frame, label_text="")
        self.objectives_frame.grid(row=5, column=0, columnspan=2, padx=10, pady=(0,10), sticky="nsew")
        links_pane = ctk.CTkFrame(self.editor_frame)
        links_pane.grid(row=6, column=0, columnspan=2, padx=10, pady=5, sticky="ew")
        links_pane.grid_columnconfigure((0,1), weight=1)
        npc_link_frame = ctk.CTkFrame(links_pane)
        npc_link_frame.grid(row=0, column=0, padx=(0,5), sticky="nsew")
        npc_link_frame.grid_columnconfigure(0, weight=1)
        npc_link_header = ctk.CTkFrame(npc_link_frame, fg_color="transparent")
        npc_link_header.pack(fill="x")
        ctk.CTkLabel(npc_link_header, text="Linked NPCs").pack(side="left")
        ctk.CTkButton(npc_link_header, text="Add", width=50, command=controller.show_add_npc_dialog).pack(side="right")
        self.linked_npcs_frame = ctk.CTkScrollableFrame(npc_link_frame, label_text="")
        self.linked_npcs_frame.pack(fill="both", expand=True)
        item_link_frame = ctk.CTkFrame(links_pane)
        item_link_frame.grid(row=0, column=1, padx=(5,0), sticky="nsew")
        item_link_frame.grid_columnconfigure(0, weight=1)
        item_link_header = ctk.CTkFrame(item_link_frame, fg_color="transparent")
        item_link_header.pack(fill="x")
        ctk.CTkLabel(item_link_header, text="Linked Items").pack(side="left")
        ctk.CTkButton(item_link_header, text="Add", width=50, command=controller.show_add_item_dialog).pack(side="right")
        self.linked_items_frame = ctk.CTkScrollableFrame(item_link_frame, label_text="")
        self.linked_items_frame.pack(fill="both", expand=True)
        button_frame = ctk.CTkFrame(self.editor_frame, fg_color="transparent")
        button_frame.grid(row=7, column=0, columnspan=2, pady=10)
        ctk.CTkButton(button_frame, text="Save Changes", command=controller.save_changes).grid(row=0, column=0, padx=5)
        ctk.CTkButton(button_frame, text="Delete Quest", command=controller.delete_quest, fg_color="#D2691E").grid(row=0, column=1, padx=5)
        self.editor_is_built = True

    def populate_editor(self, quest):
        """Populates the pre-existing editor widgets with new data."""
        self.editor_label.configure(text=f"Editing: {quest['title']}")
        self.title_entry.delete(0, 'end')
        self.title_entry.insert(0, quest['title'])
        self.status_combo.set(quest['status'])
        self.desc_text.delete("1.0", "end")
        self.desc_text.insert("1.0", quest['description'])
        
    def clear_editor(self):
        """Hides the editor content and shows a placeholder."""
        for widget in self.editor_frame.winfo_children():
            widget.destroy()
        self.editor_is_built = False
        self.placeholder_label = ctk.CTkLabel(self.editor_frame, text="Select a quest to view or create a new one.", font=ctk.CTkFont(size=16))
        self.placeholder_label.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)
        
    def show_editor_widgets(self):
        if hasattr(self, 'placeholder_label'):
            self.placeholder_label.destroy()

    def display_quest_list(self, quests_by_status, controller):
        """Rebuilds the categorized and color-coded list of quest buttons."""
        for widget in self.quest_list_scroll_frame.winfo_children():
            widget.destroy()
        self.quest_buttons.clear()
        status_map = {
            "Active": {"order": 1, "color": "#3B8ED0"},
            "Inactive": {"order": 2, "color": "gray50"},
            "Completed": {"order": 3, "color": "#228B22"},
            "Failed": {"order": 4, "color": "#D2691E"}
        }
        sorted_statuses = sorted(quests_by_status.keys(), key=lambda s: status_map.get(s, {}).get("order", 99))
        for status in sorted_statuses:
            if not quests_by_status[status]: continue
            header_color = status_map.get(status, {"color": "gray25"})["color"]
            header_frame = ctk.CTkFrame(self.quest_list_scroll_frame, fg_color=header_color, corner_radius=5)
            header_frame.pack(fill="x", pady=(8, 2))
            ctk.CTkLabel(header_frame, text=status, font=ctk.CTkFont(size=14, weight="bold")).pack(padx=10, pady=5)
            for quest in sorted(quests_by_status[status], key=lambda q: q['title'].lower()):
                quest_row = ctk.CTkButton(self.quest_list_scroll_frame, text=quest["title"], anchor="w", fg_color="gray25",
                                         command=lambda q=quest: controller.select_quest(q))
                quest_row.pack(fill="x", pady=0, padx=10)
                self.quest_buttons[quest['id']] = quest_row

    def highlight_selected_quest(self, selected_quest_id=None):
        """Updates the border of the selected quest button."""
        for quest_id, button in self.quest_buttons.items():
            if quest_id == selected_quest_id:
                button.configure(border_width=2, border_color="#FFFFFF")
            else:
                button.configure(border_width=0)

    def redraw_objectives(self, objectives, controller):
        for widget in self.objectives_frame.winfo_children():
            widget.destroy()
        for i, obj in enumerate(objectives):
            obj_row = ctk.CTkFrame(self.objectives_frame, fg_color="transparent")
            obj_row.pack(fill="x", pady=2)
            check = ctk.CTkCheckBox(obj_row, text="", width=20, command=lambda idx=i: controller.toggle_objective(idx))
            if obj['completed']: check.select()
            check.pack(side="left")
            entry = ctk.CTkEntry(obj_row)
            entry.insert(0, obj['text'])
            entry.bind("<KeyRelease>", lambda event, idx=i, w=entry: controller.update_objective_text(idx, w.get()))
            entry.pack(side="left", fill="x", expand=True, padx=5)
            ctk.CTkButton(obj_row, text="-", width=30, fg_color="gray50", command=lambda idx=i: controller.remove_objective(idx)).pack(side="right")

    def redraw_links(self, linked_npcs, linked_items, all_npcs, all_items, controller):
        for widget in self.linked_npcs_frame.winfo_children():
            widget.destroy()
        for npc_id in linked_npcs:
            npc = next((n for n in all_npcs if n['id'] == npc_id), None)
            if npc:
                link_row = ctk.CTkFrame(self.linked_npcs_frame, fg_color="transparent")
                link_row.pack(fill="x", pady=2)
                ctk.CTkLabel(link_row, text=npc['name'], anchor="w").pack(side="left", fill="x", expand=True)
                ctk.CTkButton(link_row, text="X", width=25, fg_color="#D2691E", command=lambda i=npc_id: controller.remove_link("npc", i)).pack(side="right")
        for widget in self.linked_items_frame.winfo_children():
            widget.destroy()
        for item_id in linked_items:
            item = next((i for i in all_items if i['id'] == item_id), None)
            if item:
                link_row = ctk.CTkFrame(self.linked_items_frame, fg_color="transparent")
                link_row.pack(fill="x", pady=2)
                ctk.CTkLabel(link_row, text=item['name'], anchor="w").pack(side="left", fill="x", expand=True)
                ctk.CTkButton(link_row, text="X", width=25, fg_color="#D2691E", command=lambda i=item_id: controller.remove_link("item", i)).pack(side="right")

================================================================================
--- FILE: combat/combat_controller.py ---
================================================================================

from .combat_model import CombatModel
from .combat_view import CombatView
from character.character_controller import CharacterController
from npc.npc_controller import NpcController
from character.character_model import CharacterModel
from npc.npc_model import NpcModel
from custom_dialogs import MessageBox

class CombatController:
    """Controller for the new Combat Tracker feature."""
    def __init__(self, app_controller, parent_frame, campaign_path):
        self.app_controller = app_controller
        self.model = CombatModel()
        self.view = CombatView(parent_frame)
        self.view.setup_ui(self)
        self.campaign_path = campaign_path
        self.current_rule_set = None
        self.available_combatants = []

    def handle_rule_set_load(self, rule_set):
        self.current_rule_set = rule_set
        self.update_combatant_lists()

    def update_combatant_lists(self):
        if not self.current_rule_set: return
        self.available_combatants = []
        
        char_controller = self.app_controller.get_loaded_controller(CharacterController)
        if char_controller:
            self.available_combatants.extend(char_controller.get_character_list())

        npc_controller = self.app_controller.get_loaded_controller(NpcController)
        if npc_controller:
            self.available_combatants.extend(npc_controller.get_npc_list())

        self.view.update_available_list(self.available_combatants, self)

    def add_to_roster(self, base_model):
        is_pc = isinstance(base_model, CharacterModel)
        if is_pc:
            for combatant in self.model.combatants.values():
                if combatant['base_model'].name == base_model.name and combatant['is_pc']:
                    MessageBox.showwarning("Warning", f"Player Character '{base_model.name}' is already in the encounter.", self.view.frame)
                    return
        self.model.add_combatant(base_model, is_pc)
        self.view.update_roster_list(self.model.combatants, self)

    def remove_from_roster(self, combatant_id):
        self.model.remove_combatant(combatant_id)
        self.view.update_roster_list(self.model.combatants, self)

    def start_combat(self):
        if not self.model.combatants:
            MessageBox.showinfo("Info", "Add combatants to the roster before starting combat.", self.view.frame)
            return
        self.model.start_combat()
        
        # --- FIX: Call the one-time UI setup, then update the list ---
        self.view.display_tracker_ui(self)
        self._update_turn_order_view()

    def next_turn(self):
        self.model.next_turn()
        self._update_turn_order_view()

    def end_combat(self):
        for combatant_data in self.model.combatants.values():
            base_model = combatant_data['base_model']
            final_hp = combatant_data['current_hp']
            base_model.current_hp = str(final_hp)
            base_model.save()
        self.model.reset_roster()
        self.view.clear_view()
        self.view.update_roster_list(self.model.combatants, self)
        self.app_controller.refresh_char_npc_sheet_if_loaded()
        self.update_combatant_lists()
        MessageBox.showinfo("Combat Ended", "Combat has ended. Current Hit Points have been saved.", self.view.frame)

    def apply_damage(self):
        combatant = self.model.get_current_combatant()
        if not combatant: return
        try:
            amount = int(self.view.action_value_entry.get())
            self.model.apply_damage(combatant['id'], amount)
            self._update_turn_order_view()
        except (ValueError, TypeError): pass
        self.view.action_value_entry.delete(0, 'end')

    def apply_healing(self):
        combatant = self.model.get_current_combatant()
        if not combatant: return
        try:
            amount = int(self.view.action_value_entry.get())
            self.model.apply_healing(combatant['id'], amount)
            self._update_turn_order_view()
        except (ValueError, TypeError): pass
        self.view.action_value_entry.delete(0, 'end')

    def set_status(self, combatant_id, text):
        self.model.set_status(combatant_id, text)

    def move_combatant_up(self, combatant_id):
        self.model.move_combatant_up(combatant_id)
        self._update_turn_order_view()

    def move_combatant_down(self, combatant_id):
        self.model.move_combatant_down(combatant_id)
        self._update_turn_order_view()

    def _update_turn_order_view(self):
        """
        --- FIX: Renamed from _redraw_tracker for clarity. ---
        This method now only calls the list update function.
        """
        current_combatant = self.model.get_current_combatant()
        current_id = current_combatant['id'] if current_combatant else None
        self.view.update_turn_order_list(self.model.turn_order, self.model.combatants, current_id, self)

================================================================================
--- FILE: combat/combat_model.py ---
================================================================================

import random
import uuid

class CombatModel:
    """A stateful model for managing a single combat encounter."""
    def __init__(self):
        self.combatants = {}
        self.turn_order = []
        self.current_turn_index = -1
        self.is_active = False

    def add_combatant(self, base_model, is_pc):
        unique_id = str(uuid.uuid4())
        name = base_model.name
        if not is_pc:
            count = 1
            while any(c['name'] == name for c in self.combatants.values()):
                count += 1
                name = f"{base_model.name} {count}"
        try:
            dex_val = int(base_model.attributes.get("Dexterity", 10))
            max_hp_val = int(base_model.attributes.get("Hit Points", 10))
            current_hp_val = int(base_model.current_hp)
        except (ValueError, TypeError, AttributeError):
            dex_val, max_hp_val, current_hp_val = 10, 10, 10
        self.combatants[unique_id] = {
            "id": unique_id, "base_model": base_model, "name": name,
            "is_pc": is_pc, "initiative": 0, "dexterity": dex_val,
            "max_hp": max_hp_val, "current_hp": current_hp_val, "status": ""
        }
        return self.combatants[unique_id]

    def remove_combatant(self, combatant_id):
        if combatant_id in self.combatants:
            del self.combatants[combatant_id]

    def start_combat(self):
        if not self.combatants: return
        for combatant in self.combatants.values():
            dex_modifier = (combatant["dexterity"] - 10) // 2
            combatant["initiative"] = random.randint(1, 20) + dex_modifier
        self.turn_order = sorted(self.combatants.keys(), key=lambda cid: self.combatants[cid]["initiative"], reverse=True)
        self.is_active = True
        self.current_turn_index = 0

    def next_turn(self):
        if not self.is_active or not self.turn_order: return
        self.current_turn_index = (self.current_turn_index + 1) % len(self.turn_order)

    def get_current_combatant(self):
        if not self.is_active or not self.turn_order: return None
        combatant_id = self.turn_order[self.current_turn_index]
        return self.combatants.get(combatant_id)
        
    def apply_damage(self, combatant_id, amount):
        if combatant_id in self.combatants:
            self.combatants[combatant_id]["current_hp"] -= amount

    def apply_healing(self, combatant_id, amount):
        if combatant_id in self.combatants:
            combatant = self.combatants[combatant_id]
            combatant["current_hp"] = min(combatant["max_hp"], combatant["current_hp"] + amount)

    def set_status(self, combatant_id, status_text):
        if combatant_id in self.combatants:
            self.combatants[combatant_id]["status"] = status_text

    def reset_roster(self):
        self.is_active = False
        self.turn_order = []
        self.current_turn_index = -1
        self.combatants.clear()

    # --- NEW: Methods to manually adjust turn order ---
    def move_combatant_up(self, combatant_id):
        """Moves a combatant one position up in the turn order."""
        if combatant_id not in self.turn_order: return
        idx = self.turn_order.index(combatant_id)
        if idx > 0:
            self.turn_order[idx], self.turn_order[idx - 1] = self.turn_order[idx - 1], self.turn_order[idx]
            # If the moved combatant was the current one, update the index
            if self.current_turn_index == idx:
                self.current_turn_index -= 1
            elif self.current_turn_index == idx - 1:
                self.current_turn_index += 1

    def move_combatant_down(self, combatant_id):
        """Moves a combatant one position down in the turn order."""
        if combatant_id not in self.turn_order: return
        idx = self.turn_order.index(combatant_id)
        if idx < len(self.turn_order) - 1:
            self.turn_order[idx], self.turn_order[idx + 1] = self.turn_order[idx + 1], self.turn_order[idx]
            if self.current_turn_index == idx:
                self.current_turn_index += 1
            elif self.current_turn_index == idx + 1:
                self.current_turn_index -= 1

================================================================================
--- FILE: combat/combat_view.py ---
================================================================================

import customtkinter as ctk

class CombatView:
    """Manages the UI for the new Combat Tracker feature."""
    def __init__(self, parent_frame):
        self.frame = parent_frame
        self.roster_buttons = {}
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_rowconfigure(0, weight=1)

    def setup_ui(self, controller):
        """Builds the initial UI layout."""
        self.main_pane = ctk.CTkFrame(self.frame, fg_color="transparent")
        self.main_pane.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        self.main_pane.grid_columnconfigure(0, weight=1)
        self.main_pane.grid_columnconfigure(1, weight=2)
        self.main_pane.grid_rowconfigure(0, weight=1)

        self.setup_pane = ctk.CTkFrame(self.main_pane)
        self.setup_pane.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        self.setup_pane.grid_rowconfigure(1, weight=1)
        self.setup_pane.grid_rowconfigure(3, weight=1)

        ctk.CTkLabel(self.setup_pane, text="Available Combatants", font=ctk.CTkFont(size=14, weight="bold")).grid(row=0, column=0, pady=5)
        self.available_list = ctk.CTkScrollableFrame(self.setup_pane)
        self.available_list.grid(row=1, column=0, sticky="nsew", padx=5)

        ctk.CTkLabel(self.setup_pane, text="Encounter Roster", font=ctk.CTkFont(size=14, weight="bold")).grid(row=2, column=0, pady=5)
        self.roster_list = ctk.CTkScrollableFrame(self.setup_pane)
        self.roster_list.grid(row=3, column=0, sticky="nsew", padx=5)

        ctk.CTkButton(self.setup_pane, text="Start Combat", command=controller.start_combat).grid(row=4, column=0, pady=10)

        self.tracker_pane = ctk.CTkFrame(self.main_pane)
        self.tracker_pane.grid_rowconfigure(0, weight=1)
        self.tracker_pane.grid_columnconfigure(0, weight=1)

        self.tracker_list = ctk.CTkScrollableFrame(self.tracker_pane, label_text="Turn Order")
        self.tracker_list.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        self.action_frame = ctk.CTkFrame(self.tracker_pane, fg_color="transparent")
        self.action_frame.grid(row=1, column=0, sticky="ew", padx=5, pady=5)
        
        self.bottom_frame = ctk.CTkFrame(self.tracker_pane, fg_color="transparent")
        self.bottom_frame.grid(row=2, column=0, sticky="ew", padx=5, pady=10)

    def update_available_list(self, available_combatants, controller):
        for widget in self.available_list.winfo_children():
            widget.destroy()
        for model in available_combatants:
            btn = ctk.CTkButton(self.available_list, text=f"+ {model.name}", anchor="w",
                                command=lambda m=model: controller.add_to_roster(m))
            btn.pack(fill="x", pady=2)

    def update_roster_list(self, roster, controller):
        for widget in self.roster_list.winfo_children():
            widget.destroy()
        for combatant in roster.values():
            btn = ctk.CTkButton(self.roster_list, text=f"- {combatant['name']}", anchor="w", fg_color="#D2691E",
                                command=lambda cid=combatant['id']: controller.remove_from_roster(cid))
            btn.pack(fill="x", pady=2)

    def display_tracker_ui(self, controller):
        """
        --- One-time setup for the tracker UI. ---
        This is called only when combat starts.
        """
        self.setup_pane.grid_forget()
        self.tracker_pane.grid(row=0, column=1, sticky="nsew", padx=(10, 0))
        self._display_actions(controller)
        self._display_bottom_buttons(controller)

    def update_turn_order_list(self, turn_order, combatants_data, current_turn_id, controller):
        """
        --- Dynamically redraws only the list of combatants. ---
        This is called every time the turn order changes.
        """
        for widget in self.tracker_list.winfo_children():
            widget.destroy()

        for index, combatant_id in enumerate(turn_order):
            combatant = combatants_data[combatant_id]
            is_current = (combatant_id == current_turn_id)
            row_color = "#3B8ED0" if is_current else "gray20"
            row = ctk.CTkFrame(self.tracker_list, fg_color=row_color, corner_radius=5)
            row.pack(fill="x", pady=3, padx=5)
            
            row.grid_columnconfigure(1, weight=1)
            row.grid_columnconfigure(2, weight=1)
            
            initiative_label = ctk.CTkLabel(row, text=f'{combatant["initiative"]}', font=ctk.CTkFont(size=16, weight="bold"), width=30)
            initiative_label.grid(row=0, column=0, rowspan=2, padx=10, pady=5)
            name_label = ctk.CTkLabel(row, text=f'{combatant["name"]}', anchor="w", font=ctk.CTkFont(size=14, weight="bold"))
            name_label.grid(row=0, column=1, sticky="w", padx=5)
            hp_text = f'HP: {combatant["current_hp"]} / {combatant["max_hp"]}'
            hp_label = ctk.CTkLabel(row, text=hp_text, anchor="w")
            hp_label.grid(row=1, column=1, sticky="w", padx=5)
            status_label = ctk.CTkLabel(row, text="Status / Notes:", anchor="w", font=ctk.CTkFont(size=12))
            status_label.grid(row=0, column=2, sticky="sw", padx=10, pady=(0,2))
            status_entry = ctk.CTkEntry(row)
            status_entry.grid(row=1, column=2, padx=10, pady=(0, 5), sticky="ew")
            status_entry.insert(0, combatant["status"])
            status_entry.bind("<FocusOut>", lambda event, cid=combatant_id, w=status_entry: controller.set_status(cid, w.get()))

            move_button_frame = ctk.CTkFrame(row, fg_color="transparent")
            move_button_frame.grid(row=0, column=3, rowspan=2, padx=5, pady=5)
            up_button = ctk.CTkButton(move_button_frame, text="▲", width=25,
                                      command=lambda cid=combatant_id: controller.move_combatant_up(cid))
            up_button.pack(pady=(2,1))
            down_button = ctk.CTkButton(move_button_frame, text="▼", width=25,
                                        command=lambda cid=combatant_id: controller.move_combatant_down(cid))
            down_button.pack(pady=(1,2))

            if index == 0:
                up_button.configure(state="disabled")
            if index == len(turn_order) - 1:
                down_button.configure(state="disabled")

    def _display_actions(self, controller):
        for widget in self.action_frame.winfo_children():
            widget.destroy()
        self.action_frame.grid_columnconfigure(1, weight=1)
        ctk.CTkLabel(self.action_frame, text="Value:").grid(row=0, column=0, padx=5)
        self.action_value_entry = ctk.CTkEntry(self.action_frame)
        self.action_value_entry.grid(row=0, column=1, padx=5, sticky="ew")
        ctk.CTkButton(self.action_frame, text="Apply Damage", command=controller.apply_damage).grid(row=0, column=2, padx=5)
        ctk.CTkButton(self.action_frame, text="Apply Healing", command=controller.apply_healing).grid(row=0, column=3, padx=5)

    def _display_bottom_buttons(self, controller):
        for widget in self.bottom_frame.winfo_children():
            widget.destroy()
        ctk.CTkButton(self.bottom_frame, text="Next Turn >", command=controller.next_turn).pack(side="left", padx=10, pady=5)
        ctk.CTkButton(self.bottom_frame, text="End Combat", command=controller.end_combat, fg_color="#D2691E").pack(side="right", padx=10, pady=5)

    def clear_view(self):
        self.tracker_pane.grid_forget()
        self.setup_pane.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        for w in self.tracker_list.winfo_children(): w.destroy()

================================================================================
--- FILE: npc/npc_controller.py ---
================================================================================

from tkinter import messagebox
from .npc_model import NpcModel
from .npc_view import NpcView
from custom_dialogs import MessageBox
from character.character_view import AddItemDialog
from item.item_controller import ItemController
from quest.quest_controller import QuestController
from .npc_generator_model import NpcGeneratorModel

class NpcController:
    def __init__(self, app_controller, parent_frame, campaign_path):
        self.app_controller = app_controller
        self.view = NpcView(parent_frame)
        self.campaign_path = campaign_path
        self.current_rule_set = None
        self.current_npc = None
        self.generated_npc_data = None
        self.view.setup_ui(self)

        # --- LAZY LOAD: Load data when controller is created ---
        self.app_controller._reload_npc_cache()

    def get_item_controller(self):
        return self.app_controller.get_loaded_controller(ItemController)

    def get_quest_controller(self):
        return self.app_controller.get_loaded_controller(QuestController)

    def get_npc_list(self):
        if self.current_rule_set:
            cache_key = f"npcs_models_{self.current_rule_set['name']}"
            return self.app_controller.get_cached_data(cache_key) or []
        return []

    def handle_rule_set_load(self, rule_set):
        self.current_rule_set = rule_set
        self.view.build_dynamic_fields(rule_set)
        self.view.build_sheet_ui(rule_set, self)
        self.update_npc_management_list()
        self.update_npc_sheet_list()

    def update_npc_management_list(self):
        if self.current_rule_set:
            npcs = self.get_npc_list()
            npc_names = [npc.name for npc in npcs]
            self.view.update_npc_management_list(npc_names)
        else:
            self.view.update_npc_management_list([])
            
    def update_npc_sheet_list(self):
        if self.current_rule_set:
            npcs = self.get_npc_list()
            npc_names = [npc.name for npc in npcs]
            self.view.update_npc_sheet_list(npc_names)
        else:
            self.view.update_npc_sheet_list([])
        self.view.clear_sheet()
        self.current_npc = None

    def generate_random_npc(self):
        if not self.current_rule_set:
            MessageBox.showerror("Error", "A rule set must be loaded to generate an NPC.", self.view.parent_frame)
            return
        item_controller = self.get_item_controller()
        if not item_controller:
            MessageBox.showerror("Error", "The Item Editor must be open to generate items.", self.view.parent_frame)
            return
        generator = NpcGeneratorModel()
        npc_data = generator.generate(self.current_rule_set)
        created_items = []
        all_item_names = [item['name'].lower() for item in item_controller.all_items]
        for item_to_create_data in npc_data["items_to_create"]:
            if item_to_create_data["name"].lower() not in all_item_names:
                new_item = item_controller.create_item_from_data(item_to_create_data)
                created_items.append(new_item)
            else:
                for item in item_controller.all_items:
                    if item['name'].lower() == item_to_create_data['name'].lower():
                        created_items.append(item)
                        break
        item_controller.load_all_items()
        self.generated_npc_data = npc_data
        self.generated_npc_data['created_items'] = created_items
        self.view.populate_creator_fields(npc_data)
        MessageBox.showinfo("NPC Generated", f"Generated a new {npc_data['name']}! Review and save when ready.", self.view.parent_frame)

    def save_new_npc(self):
        if not self.current_rule_set:
            MessageBox.showerror("Error", "No rule set loaded.", self.view.parent_frame)
            return
        name = self.view.npc_name_entry.get()
        if not name:
            MessageBox.showerror("Error", "NPC name is required.", self.view.parent_frame)
            return
        npc = NpcModel(self.campaign_path, name, self.current_rule_set['name'])
        for key, entry in self.view.npc_creator_entries.items():
            value = entry.get() or "0"
            if key in self.current_rule_set['attributes']:
                npc.attributes[key] = value
            elif key in self.current_rule_set['skills']:
                npc.skills[key] = value
        npc.current_hp = npc.attributes.get("Hit Points", "10")
        npc.gm_notes = self.view.npc_notes_text.get("1.0", "end-1c")
        if self.generated_npc_data and self.generated_npc_data["name"] == name:
            for item in self.generated_npc_data.get("created_items", []):
                npc.inventory.append({"item_id": item["id"], "quantity": 1, "equipped": True})
        npc.save()
        MessageBox.showinfo("Success", f"NPC '{name}' saved.", self.view.parent_frame)

        self.app_controller.on_character_or_npc_list_changed()
        self.view.clear_creator_fields()
        self.generated_npc_data = None

    def delete_selected_npc(self):
        npc_name = self.view.npc_management_list.get().strip()
        if not npc_name or npc_name == "-":
            MessageBox.showerror("Error", "Please select an NPC from the list to delete.", self.view.parent_frame)
            return
        if MessageBox.askyesno("Confirm Deletion", f"Are you sure you want to permanently delete {npc_name}?", self.view.parent_frame):
            if NpcModel.delete(self.campaign_path, npc_name):
                MessageBox.showinfo("Deleted", f"NPC '{npc_name}' has been deleted.", self.view.parent_frame)
                
                self.app_controller.on_character_or_npc_list_changed()
            else:
                MessageBox.showerror("Error", f"Could not find file for NPC '{npc_name}'.", self.view.parent_frame)

    def load_npc_to_sheet(self, refresh=False):
        item_controller = self.get_item_controller()
        quest_controller = self.get_quest_controller()

        npc_name = self.current_npc.name if (refresh and self.current_npc) else self.view.npc_sheet_list.get().strip()
        if not npc_name or npc_name == "-":
            self.current_npc = None
            self.view.clear_sheet()
            return
            
        self.current_npc = NpcModel.load(self.campaign_path, npc_name)
        if not self.current_npc:
            MessageBox.showerror("Error", f"Could not load NPC: {npc_name}", self.view.parent_frame)
            return
        
        # The view will handle cases where controllers are None
        self.view.display_sheet_data(self.current_npc, item_controller, self)
        
        if not refresh:
            self.app_controller.set_dirty_flag(False)
        
    def save_npc_sheet(self):
        if not self.current_npc: return
        self.current_npc.current_hp = self.view.current_hp_entry.get()
        for key, entry in self.view.npc_sheet_entries.items():
            full_value = entry.get()
            if "(" in full_value and full_value.endswith(")"):
                base_value = full_value.split('(')[-1].strip(')')
            else:
                base_value = full_value
            if key in self.current_npc.attributes:
                self.current_npc.attributes[key] = base_value
            elif key in self.current_npc.skills:
                self.current_npc.skills[key] = base_value
        self.current_npc.gm_notes = self.view.sheet_notes_text.get("1.0", "end-1c")
        self.current_npc.save()
        self.app_controller.set_dirty_flag(False)
        MessageBox.showinfo("Success", f"Changes to '{self.current_npc.name}' saved.", self.view.parent_frame)

    def delete_current_npc(self):
        if not self.current_npc: return
        npc_name = self.current_npc.name
        if MessageBox.askyesno("Confirm Deletion", f"Are you sure you want to permanently delete {npc_name}?", self.view.parent_frame):
            if NpcModel.delete(self.campaign_path, npc_name):
                MessageBox.showinfo("Deleted", f"NPC '{npc_name}' has been deleted.", self.view.parent_frame)
                self.current_npc = None
                self.view.clear_sheet()
                self.app_controller.on_character_or_npc_list_changed()
                self.app_controller.set_dirty_flag(False)
            else:
                MessageBox.showerror("Error", f"Could not find file for NPC '{npc_name}'.", self.view.parent_frame)

    def show_add_item_dialog(self):
        if not self.current_npc: return
        item_controller = self.get_item_controller()
        if not item_controller:
            MessageBox.showerror("Error", "The 'Items' feature must be open in a pane to add items.", self.view.parent_frame)
            return
        dialog = AddItemDialog(parent=self.view.parent_frame, all_items=item_controller.all_items)
        selected_item = dialog.get_selection()
        if selected_item:
            self.add_item_to_inventory(selected_item)

    def add_item_to_inventory(self, item_to_add):
        if not self.current_npc: return
        item_controller = self.get_item_controller()
        if not item_controller: return
        for inv_entry in self.current_npc.inventory:
            if inv_entry["item_id"] == item_to_add["id"]:
                inv_entry["quantity"] += 1
                break
        else:
            self.current_npc.inventory.append({"item_id": item_to_add["id"], "quantity": 1, "equipped": False})
        self.view.display_sheet_data(self.current_npc, item_controller, self)
        self.mark_as_dirty()

    def remove_item_from_inventory(self, inv_entry_to_remove):
        if not self.current_npc: return
        item_controller = self.get_item_controller()
        if not item_controller: return
        for i, inv_entry in enumerate(self.current_npc.inventory):
            if inv_entry["item_id"] == inv_entry_to_remove["item_id"]:
                inv_entry["quantity"] -= 1
                if inv_entry["quantity"] <= 0:
                    self.current_npc.inventory.pop(i)
                break
        self.view.display_sheet_data(self.current_npc, item_controller, self)
        self.mark_as_dirty()

    def toggle_item_equipped(self, inv_entry_to_toggle):
        if not self.current_npc: return
        item_controller = self.get_item_controller()
        if not item_controller: return
        for inv_entry in self.current_npc.inventory:
            if inv_entry["item_id"] == inv_entry_to_toggle["item_id"]:
                inv_entry["equipped"] = not inv_entry.get("equipped", False)
                break
        self.view.display_sheet_data(self.current_npc, item_controller, self)
        self.mark_as_dirty()
                
    def mark_as_dirty(self, event=None):
        self.app_controller.set_dirty_flag(True)

================================================================================
--- FILE: npc/npc_generator_model.py ---
================================================================================

import random

class NpcGeneratorModel:
    """
    A service model for generating random but plausible NPC data, now with awareness
    of multiple TTRPG systems and genres.
    """

    def __init__(self):
        # The entire data structure is now organized by game system/genre.
        self.systems = {
            "D&D / Fantasy": {
                "keywords": ["Strength", "Dexterity", "Constitution", "Wisdom", "Charisma", "Intelligence"],
                "archetypes": {
                    "Fighter": {
                        "primary_stats": ["Strength", "Hit Points"], "occupations": ["Town Guard", "Mercenary", "Veteran", "Gladiator"],
                        "items": [{"name": "Longsword", "type": "Weapon", "description": "A standard steel longsword.", "modifiers": []}, {"name": "Chainmail Armor", "type": "Armor", "description": "A suit of interlocking metal rings.", "modifiers": [{"stat": "Dodge Chance", "value": -2}]}]
                    },
                    "Rogue": {
                        "primary_stats": ["Dexterity", "Stealth"], "occupations": ["Thief", "Spy", "Assassin", "Scout"],
                        "items": [{"name": "Dagger", "type": "Weapon", "description": "A small, easily concealed dagger.", "modifiers": []}, {"name": "Leather Armor", "type": "Armor", "description": "Armor made of hardened leather.", "modifiers": []}]
                    },
                    "Wizard": {
                        "primary_stats": ["Intelligence", "Arcana"], "occupations": ["Hedge Mage", "Court Wizard", "Scholar"],
                        "items": [{"name": "Wizard Robes", "type": "Armor", "description": "Flowing robes with arcane embroidery.", "modifiers": []}, {"name": "Quarterstaff", "type": "Weapon", "description": "A sturdy oaken staff.", "modifiers": [{"stat": "Magic", "value": 1}]}]
                    },
                    "Cleric": {
                        "primary_stats": ["Wisdom", "Medicine"], "occupations": ["Acolyte", "Traveling Healer", "Temple Priest"],
                        "items": [{"name": "Mace", "type": "Weapon", "description": "A blunt-force weapon favored by clerics.", "modifiers": []}, {"name": "Holy Symbol", "type": "Miscellaneous", "description": "A silver amulet of a deity.", "modifiers": [{"stat": "Wisdom", "value": 1}]}]
                    },
                    "Barbarian": {
                        "primary_stats": ["Strength", "Constitution", "Intimidation"], "occupations": ["Tribal Outcast", "Raider", "Pit Fighter"],
                        "items": [{"name": "Greataxe", "type": "Weapon", "description": "A massive, intimidating axe.", "modifiers": []}, {"name": "Hide Armor", "type": "Armor", "description": "Armor made from the thick hides of beasts.", "modifiers": []}]
                    },
                },
                "names": ["Alden", "Bram", "Faye", "Gwen", "Ronan", "Seraphina", "Kael", "Moira"],
                "surnames": ["Blackwood", "Stonehand", "Swiftwater", "Greycastle", "Oakenshield"],
                "origins": ["Raised in a quiet farming village,", "Trained from a young age in a remote monastery,", "The sole survivor of a goblin raid on their caravan,"],
                "goals": ["avenge a fallen mentor.", "find a lost family heirloom.", "reclaim their ancestral lands from orcs."],
                "secrets": ["is secretly a member of the thieves' guild.", "possesses a cursed magic item they cannot get rid of.", "is the illegitimate heir to a minor noble house."],
            },
            "Cyberpunk": {
                "keywords": ["Reflexes", "Tech", "Cool", "Body", "Empathy"],
                "archetypes": {
                    "Solo": {
                        "primary_stats": ["Reflexes", "Body", "Handguns", "Rifles"], "occupations": ["Corporate Enforcer", "Mercenary", "Cyberpsycho Hunter"],
                        "items": [{"name": "Heavy Pistol", "type": "Weapon", "description": "A reliable, high-caliber sidearm.", "modifiers": []}, {"name": "Armored Vest", "type": "Armor", "description": "Standard-issue kevlar body armor.", "modifiers": []}]
                    },
                    "Netrunner": {
                        "primary_stats": ["Intelligence", "Hacking", "Electronics"], "occupations": ["Data Thief", "System Saboteur", "Cyber-Detective"],
                        "items": [{"name": "Cyberdeck", "type": "Miscellaneous", "description": "A high-end deck for navigating the Net.", "modifiers": [{"stat": "Hacking", "value": 2}]}, {"name": "Light Pistol", "type": "Weapon", "description": "A small pistol for self-defense.", "modifiers": []}]
                    },
                    "Techie": {
                        "primary_stats": ["Tech", "Engineering", "Crafting"], "occupations": ["Ripperdoc", "Mechanic", "Weaponsmith"],
                        "items": [{"name": "Tech Toolkit", "type": "Miscellaneous", "description": "A full set of advanced cybernetic and electronic tools.", "modifiers": [{"stat": "Tech", "value": 2}]}, {"name": "Heavy Wrench", "type": "Weapon", "description": "It's for repairs, mostly.", "modifiers": []}]
                    },
                    "Fixer": {
                        "primary_stats": ["Cool", "Persuasion", "Streetwise"], "occupations": ["Information Broker", "Smuggler", "Gang Leader"],
                        "items": [{"name": "Burner Phone", "type": "Miscellaneous", "description": "An untraceable, disposable comms device.", "modifiers": []}, {"name": "Holdout Pistol", "type": "Weapon", "description": "A tiny pistol that's easy to conceal.", "modifiers": []}]
                    },
                },
                "names": ["Jax", "Kira", "Nash", "Rogue", "Spike", "V", "Yori", "Zane"],
                "surnames": ["Jones", "Tanaka", "Kowalski", "Singh", "Volkov", "Nix"],
                "origins": ["Grew up on the mean streets of the Combat Zone,", "An ex-corporate wage-slave who got burned,", "A nomad who left the clan for a life in the city,"],
                "goals": ["get enough eddies for a top-tier cybernetic upgrade.", "erase their past identity from a corporate database.", "take down the gang that wronged them."],
                "secrets": ["is secretly a corporate informant.", "has a piece of pre-Collapse tech they don't understand.", "is slowly succumbing to cyberpsychosis."],
            },
            "Call of Cthulhu / Horror": {
                "keywords": ["Power", "Education", "Sanity", "Luck"],
                "archetypes": {
                    "Investigator": {
                        "primary_stats": ["Investigation", "Library Use", "Spot Hidden"], "occupations": ["Private Detective", "Journalist", "Police Detective"],
                        "items": [{"name": ".38 Revolver", "type": "Weapon", "description": "A standard-issue six-shot revolver.", "modifiers": []}, {"name": "Trench Coat", "type": "Armor", "description": "A heavy coat, good for concealing things and staying anonymous.", "modifiers": []}]
                    },
                    "Professor": {
                        "primary_stats": ["Education", "Archaeology", "Occult"], "occupations": ["University Professor", "Museum Curator", "Antiquarian"],
                        "items": [{"name": "Ancient Tome", "type": "Miscellaneous", "description": "A leather-bound book filled with cryptic text.", "modifiers": [{"stat": "Sanity", "value": -5}]}, {"name": "Satchel", "type": "Miscellaneous", "description": "A leather bag for carrying books and artifacts.", "modifiers": []}]
                    },
                    "Dilettante": {
                        "primary_stats": ["Charisma", "Appraise", "Fine Art"], "occupations": ["Wealthy Heir", "Socialite", "Patron of the Arts"],
                        "items": [{"name": "Cane Sword", "type": "Weapon", "description": "An elegant walking cane with a concealed blade.", "modifiers": []}, {"name": "Expensive Suit", "type": "Armor", "description": "A perfectly tailored suit that opens doors in high society.", "modifiers": []}]
                    },
                },
                "names": ["Arthur", "Abigail", "Charles", "Eleanor", "Harvey", "Josephine", "Walter"],
                "surnames": ["Blackwood", "Armitage", "West", "Peaslee", "Derby", "Olmstead"],
                "origins": ["A respected academic at Miskatonic University,", "A hard-boiled detective haunted by a previous case,", "A wealthy socialite who dabbles in the occult for amusement,"],
                "goals": ["understand a recurring, horrifying nightmare.", "find out what happened to a missing colleague.", "debunk local superstitions, only to find they are real."],
                "secrets": ["found a strange artifact they can't get rid of.", "read a forbidden book that has started to warp their mind.", "is a member of a secret society that deals with the occult."],
            },
        }
        
        # Generic components, expanded for more variety
        self.adjectives = ["A weary", "A cheerful", "A suspicious", "A naive", "A grizzled", "An ambitious", "A cynical", "A paranoid", "A hopeful"]
        self.voices = ["deep and gravelly", "high and melodic", "fast and clipped", "slow and deliberate", "hoarse and quiet", "booming and confident", "soft and breathy", "nasal and whiny", "smooth and charming"]
        self.mannerisms = ["constantly fidgets with a coin", "avoids direct eye contact", "has a noticeable limp", "often quotes obscure texts", "tends to stare off into the distance", "taps their fingers when impatient", "cracks their knuckles", "speaks with overly formal language"]
        self.appearances = ["a jagged scar across their left eye.", "impeccably clean and well-dressed.", "covered in a light layer of grime.", "several strange tattoos on their arms.", "an air of weary sadness.", "a bright, infectious smile.", "eyes that seem to notice everything.", "a look of constant suspicion."]
    
    def _infer_system(self, rule_set):
        """Intelligently guesses the game system based on attribute names."""
        attributes = [attr.lower() for attr in rule_set.get('attributes', [])]
        for system_name, data in self.systems.items():
            matches = 0
            for keyword in data["keywords"]:
                if keyword.lower() in attributes:
                    matches += 1
            if matches >= 3: # A reasonable threshold for a match
                return system_name
        return "D&D / Fantasy" # Default if no match is found

    def generate(self, rule_set):
        """Generates a complete NPC data dictionary based on the inferred system."""
        system_name = self._infer_system(rule_set)
        system_data = self.systems[system_name]
        
        archetype_name = random.choice(list(system_data["archetypes"].keys()))
        archetype_data = system_data["archetypes"][archetype_name]

        name = f"{random.choice(system_data['names'])} {random.choice(system_data['surnames'])}"
        
        stats = {}
        all_stats = rule_set.get('attributes', []) + list(rule_set.get('skills', {}).keys())
        for stat in all_stats:
            if any(ps.lower() in stat.lower() for ps in archetype_data["primary_stats"]):
                stats[stat] = str(random.randint(13, 17))
            else:
                stats[stat] = str(random.randint(8, 12))
        
        backstory = (
            f"{random.choice(system_data['origins'])} {name.split()[0]} {random.choice(system_data['goals'])} "
            f"However, they harbor a secret: {name.split()[0]} {random.choice(system_data['secrets'])}"
        )
        
        gm_notes = (
            f"--- Backstory ---\n{backstory}\n\n"
            f"--- Appearance ---\nThey have {random.choice(self.appearances)}\n\n"
            f"--- Personality ---\n{random.choice(self.adjectives)} {random.choice(archetype_data['occupations']).lower()}.\n\n"
            f"--- Voice & Mannerisms ---\nVoice: {random.choice(self.voices)}. Mannerisms: {random.choice(self.mannerisms)}."
        )
        
        items_to_create = archetype_data["items"]

        return {
            "name": name,
            "stats": stats,
            "gm_notes": gm_notes,
            "items_to_create": items_to_create
        }

================================================================================
--- FILE: npc/npc_model.py ---
================================================================================

import json
from database import Database

class NpcModel:
    """Model for managing NPC data within a specific campaign."""
    def __init__(self, campaign_path, name, rule_set_name):
        self.campaign_path = campaign_path
        self.name = name
        self.rule_set_name = rule_set_name
        self.attributes = {}
        self.skills = {}
        self.inventory = []
        self.gm_notes = ""
        # NEW: Explicitly track current HP
        self.current_hp = None

    def to_dict(self):
        """Converts the NPC object to a dictionary for saving."""
        # Ensure current_hp is set before saving
        if self.current_hp is None:
            self.current_hp = self.attributes.get("Hit Points", "10")
        return {
            'name': self.name, 'rule_set': self.rule_set_name, 'attributes': self.attributes,
            'skills': self.skills, 'inventory': self.inventory, 'gm_notes': self.gm_notes,
            'current_hp': self.current_hp
        }

    @classmethod
    def from_dict(cls, campaign_path, data):
        """Creates an NpcModel instance from a dictionary."""
        npc = cls(campaign_path, data['name'], data['rule_set'])
        npc.attributes = data.get('attributes', {})
        npc.skills = data.get('skills', {})
        npc.gm_notes = data.get('gm_notes', "")
        
        inventory_data = data.get('inventory', [])
        for item_entry in inventory_data:
            if 'equipped' not in item_entry:
                item_entry['equipped'] = False
        npc.inventory = inventory_data
        
        # Load current_hp, defaulting to Max HP if not found (for backward compatibility)
        max_hp = npc.attributes.get("Hit Points", "10")
        npc.current_hp = data.get('current_hp', max_hp)

        return npc

    def save(self):
        """Saves the NPC data to the database."""
        db = Database(self.campaign_path)
        db.connect()
        npc_id = self.name.lower().replace(' ', '_')
        data_json = json.dumps(self.to_dict())
        db.execute(
            "INSERT OR REPLACE INTO npcs (id, name, rule_set, data) VALUES (?, ?, ?, ?)",
            (npc_id, self.name, self.rule_set_name, data_json)
        )
        db.close()

    @staticmethod
    def load(campaign_path, npc_name):
        """Loads a single NPC from the database by name."""
        db = Database(campaign_path)
        db.connect()
        npc_id = npc_name.lower().replace(' ', '_')
        row = db.fetchone("SELECT data FROM npcs WHERE id = ?", (npc_id,))
        db.close()
        if row:
            data = json.loads(row['data'])
            return NpcModel.from_dict(campaign_path, data)
        return None

    @staticmethod
    def get_all_for_ruleset(campaign_path, rule_set_name):
        """--- OPTIMIZED: Loads all NPCs for a ruleset in a single query. ---"""
        db = Database(campaign_path)
        db.connect()
        rows = db.fetchall("SELECT data FROM npcs WHERE rule_set = ?", (rule_set_name,))
        db.close()
        return [NpcModel.from_dict(campaign_path, json.loads(row['data'])) for row in rows]

    @staticmethod
    def delete(campaign_path, npc_name):
        """Deletes an NPC from the database."""
        db = Database(campaign_path)
        db.connect()
        npc_id = npc_name.lower().replace(' ', '_')
        db.execute("DELETE FROM npcs WHERE id = ?", (npc_id,))
        db.close()
        return True

================================================================================
--- FILE: npc/npc_view.py ---
================================================================================

import customtkinter as ctk
from character.character_view import AddItemDialog
from ui_extensions import AutoWidthComboBox
from quest.quest_controller import QuestController

class NpcView:
    """Manages the UI for the self-contained NPC feature."""
    def __init__(self, parent_frame):
        # The parent frame will manage this view's frame with grid
        parent_frame.grid_rowconfigure(0, weight=1)
        parent_frame.grid_columnconfigure(0, weight=1)

        self.frame = ctk.CTkTabview(parent_frame, fg_color="transparent")
        self.frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        self.creator_tab = self.frame.add("Creator")
        self.sheet_tab = self.frame.add("Sheet")
        
        self.npc_creator_entries = {}
        self.npc_sheet_entries = {}
        self.sheet_is_built = False

    def setup_ui(self, controller):
        self._setup_creator_ui(controller)
        self.setup_sheet_ui(controller)

    def _setup_creator_ui(self, controller):
        container = ctk.CTkFrame(self.creator_tab, fg_color="transparent")
        container.pack(fill="both", expand=True)
        container.grid_columnconfigure(0, weight=1)
        container.grid_rowconfigure(1, weight=1)
        ctk.CTkLabel(container, text="Create & Manage NPCs", font=ctk.CTkFont(size=18, weight="bold")).grid(row=0, column=0, pady=20, padx=20)
        main_pane = ctk.CTkFrame(container, fg_color="transparent")
        main_pane.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        main_pane.grid_columnconfigure(0, weight=2)
        main_pane.grid_columnconfigure(1, weight=1)
        main_pane.grid_rowconfigure(0, weight=1)
        create_frame = ctk.CTkFrame(main_pane)
        create_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        create_frame.grid_columnconfigure(0, weight=1)
        create_frame.grid_rowconfigure(2, weight=1)
        ctk.CTkLabel(create_frame, text="Create New NPC", font=ctk.CTkFont(size=16, weight="bold")).grid(row=0, column=0, pady=10)
        name_frame = ctk.CTkFrame(create_frame, fg_color="transparent")
        name_frame.grid(row=1, column=0, pady=5, padx=10, sticky="new")
        ctk.CTkLabel(name_frame, text="NPC Name:", anchor="w").pack(side="left", padx=5)
        self.npc_name_entry = ctk.CTkEntry(name_frame)
        self.npc_name_entry.pack(side="left", fill="x", expand=True)
        self.npc_creator_fields_frame = ctk.CTkScrollableFrame(create_frame, label_text="Attributes & Skills")
        self.npc_creator_fields_frame.grid(row=2, column=0, pady=10, padx=10, sticky="nsew")
        gm_fields_frame = ctk.CTkFrame(create_frame, fg_color="transparent")
        gm_fields_frame.grid(row=3, column=0, pady=10, padx=10, sticky="ew")
        gm_fields_frame.grid_columnconfigure((0, 1), weight=1)
        ctk.CTkLabel(gm_fields_frame, text="GM Notes:", anchor="w").grid(row=0, column=0, sticky="w")
        self.npc_notes_text = ctk.CTkTextbox(gm_fields_frame, height=80)
        self.npc_notes_text.grid(row=1, column=0, sticky="ew", padx=(0, 5))
        ctk.CTkLabel(gm_fields_frame, text="Generated Items:", anchor="w").grid(row=0, column=1, sticky="w", padx=(5,0))
        self.generated_items_list = ctk.CTkTextbox(gm_fields_frame, height=80, state="disabled", fg_color="gray20")
        self.generated_items_list.grid(row=1, column=1, sticky="ew", padx=(5, 0))
        creator_button_frame = ctk.CTkFrame(create_frame, fg_color="transparent")
        creator_button_frame.grid(row=4, column=0, pady=10, padx=10, sticky="ew")
        creator_button_frame.grid_columnconfigure((0, 1), weight=1)
        ctk.CTkButton(creator_button_frame, text="Save NPC", command=controller.save_new_npc).grid(row=0, column=0, padx=(0, 5), sticky="ew")
        ctk.CTkButton(creator_button_frame, text="Generate Random", command=controller.generate_random_npc).grid(row=0, column=1, padx=(5, 0), sticky="ew")
        manage_frame = ctk.CTkFrame(main_pane)
        manage_frame.grid(row=0, column=1, sticky="nsew", padx=(10, 0))
        ctk.CTkLabel(manage_frame, text="Existing NPCs", font=ctk.CTkFont(size=16, weight="bold")).pack(pady=10)
        self.npc_management_list = AutoWidthComboBox(manage_frame, state="readonly")
        self.npc_management_list.pack(fill="x", padx=10, pady=5)
        self.npc_management_list.bind("<Button-1>", lambda event: self.npc_management_list._open_dropdown_menu())
        ctk.CTkButton(manage_frame, text="Delete Selected NPC", command=controller.delete_selected_npc, fg_color="#D2691E", hover_color="#B2590E").pack(pady=10)

    def populate_creator_fields(self, npc_data):
        self.npc_name_entry.delete(0, 'end')
        self.npc_name_entry.insert(0, npc_data["name"])
        for key, entry in self.npc_creator_entries.items():
            entry.delete(0, 'end')
            if key in npc_data["stats"]:
                entry.insert(0, npc_data["stats"][key])
        self.npc_notes_text.delete("1.0", "end")
        self.npc_notes_text.insert("1.0", npc_data["gm_notes"])
        self.generated_items_list.configure(state="normal")
        self.generated_items_list.delete("1.0", "end")
        item_names = [item['name'] for item in npc_data.get("items_to_create", [])]
        self.generated_items_list.insert("1.0", "\n".join(item_names))
        self.generated_items_list.configure(state="disabled")

    def clear_creator_fields(self):
        self.npc_name_entry.delete(0, 'end')
        for entry in self.npc_creator_entries.values():
            entry.delete(0, 'end')
        self.npc_notes_text.delete("1.0", "end")
        self.generated_items_list.configure(state="normal")
        self.generated_items_list.delete("1.0", "end")
        self.generated_items_list.configure(state="disabled")

    def setup_sheet_ui(self, controller):
        container = ctk.CTkFrame(self.sheet_tab, fg_color="transparent")
        container.pack(fill="both", expand=True)
        container.grid_columnconfigure(0, weight=1)
        container.grid_rowconfigure(1, weight=1)
        load_frame = ctk.CTkFrame(container)
        load_frame.grid(row=0, column=0, pady=(10, 20), padx=20, sticky="ew")
        ctk.CTkLabel(load_frame, text="Load NPC:").pack(side="left", padx=(10,10))
        self.npc_sheet_list = AutoWidthComboBox(load_frame, values=["-"], state="readonly")
        self.npc_sheet_list.pack(side="left", padx=5, fill="x", expand=True)
        self.npc_sheet_list.bind("<Button-1>", lambda event: self.npc_sheet_list._open_dropdown_menu())
        ctk.CTkButton(load_frame, text="Load", command=controller.load_npc_to_sheet).pack(side="left", padx=(10,10))
        self.sheet_content_frame = ctk.CTkFrame(container, fg_color="transparent")
        self.sheet_content_frame.grid(row=1, column=0, pady=10, padx=20, sticky="nsew")

    def build_dynamic_fields(self, rule_set):
        for widget in self.npc_creator_fields_frame.winfo_children():
            widget.destroy()
        self.npc_creator_entries.clear()
        container = ctk.CTkFrame(self.npc_creator_fields_frame, fg_color="transparent")
        ctk.CTkLabel(container, text="Attributes", font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", pady=(10,5), padx=5)
        for attr in rule_set['attributes']:
            frame = ctk.CTkFrame(container, fg_color="transparent")
            frame.pack(fill="x", padx=5, pady=4)
            ctk.CTkLabel(frame, text=attr, width=150, anchor="w").pack(side="left")
            entry = ctk.CTkEntry(frame)
            entry.pack(side="left", fill="x", expand=True)
            self.npc_creator_entries[attr] = entry
        ctk.CTkLabel(container, text="Skills", font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", pady=(10,5), padx=5)
        for skill, base_attr in rule_set['skills'].items():
            frame = ctk.CTkFrame(container, fg_color="transparent")
            frame.pack(fill="x", padx=5, pady=4)
            label = f"{skill} ({base_attr[:3]})"
            ctk.CTkLabel(frame, text=label, width=150, anchor="w").pack(side="left")
            entry = ctk.CTkEntry(frame)
            entry.pack(side="left", fill="x", expand=True)
            self.npc_creator_entries[skill] = entry
        container.pack(fill="both", expand=True)

    def build_sheet_ui(self, rule_set, controller):
        self.clear_sheet()
        self.npc_sheet_entries.clear()
        self.sheet_content_wrapper = ctk.CTkFrame(self.sheet_content_frame, fg_color="transparent")
        self.sheet_content_wrapper.grid_columnconfigure((0,1), weight=1)
        self.sheet_content_wrapper.grid_rowconfigure(1, weight=1)
        self.sheet_name_label = ctk.CTkLabel(self.sheet_content_wrapper, text="", font=ctk.CTkFont(size=20, weight="bold"))
        self.sheet_name_label.grid(row=0, column=0, columnspan=2, pady=5, sticky="w", padx=10)
        stats_frame = ctk.CTkScrollableFrame(self.sheet_content_wrapper, label_text="Stats & Skills")
        stats_frame.grid(row=1, column=0, sticky="nsew", padx=(0, 10))
        hp_frame = ctk.CTkFrame(stats_frame, fg_color="gray20")
        hp_frame.pack(fill="x", padx=5, pady=5)
        hp_frame.grid_columnconfigure(1, weight=1)
        ctk.CTkLabel(hp_frame, text="Current HP:", anchor="w").grid(row=0, column=0, padx=5, pady=2)
        self.current_hp_entry = ctk.CTkEntry(hp_frame)
        self.current_hp_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.current_hp_entry.bind("<KeyRelease>", controller.mark_as_dirty)
        ctk.CTkLabel(hp_frame, text="Max HP:", anchor="w").grid(row=1, column=0, padx=5, pady=2)
        self.max_hp_label = ctk.CTkLabel(hp_frame, text="10", anchor="w")
        self.max_hp_label.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        
        gm_pane = ctk.CTkFrame(self.sheet_content_wrapper)
        gm_pane.grid(row=1, column=1, sticky="nsew", padx=(10, 0))
        gm_pane.grid_columnconfigure(0, weight=1)
        gm_pane.grid_rowconfigure(1, weight=2) # Notes expand
        gm_pane.grid_rowconfigure(3, weight=1) # Inventory expand
        gm_pane.grid_rowconfigure(5, weight=1) # Quests expand

        all_stat_keys = rule_set['attributes'] + list(rule_set['skills'].keys())
        for key in all_stat_keys:
            if key == "Hit Points": continue
            frame = ctk.CTkFrame(stats_frame, fg_color="transparent")
            frame.pack(fill="x", padx=5, pady=4)
            ctk.CTkLabel(frame, text=key, width=150, anchor="w").pack(side="left")
            entry = ctk.CTkEntry(frame)
            entry.pack(side="left", fill="x", expand=True)
            self.npc_sheet_entries[key] = entry
            entry.bind("<KeyRelease>", controller.mark_as_dirty)
            
        ctk.CTkLabel(gm_pane, text="GM Notes", font=ctk.CTkFont(size=14, weight="bold")).grid(row=0, column=0, sticky="w", pady=(0,5))
        self.sheet_notes_text = ctk.CTkTextbox(gm_pane)
        self.sheet_notes_text.grid(row=1, column=0, sticky="nsew")
        self.sheet_notes_text.bind("<KeyRelease>", controller.mark_as_dirty)
        inv_header_frame = ctk.CTkFrame(gm_pane, fg_color="transparent")
        inv_header_frame.grid(row=2, column=0, sticky="ew", pady=(10,5))
        ctk.CTkLabel(inv_header_frame, text="Inventory / Loot", font=ctk.CTkFont(size=14, weight="bold")).pack(side="left")
        ctk.CTkButton(inv_header_frame, text="Add Item", width=80, command=controller.show_add_item_dialog).pack(side="right")
        self.inventory_list_frame = ctk.CTkScrollableFrame(gm_pane)
        self.inventory_list_frame.grid(row=3, column=0, sticky="nsew")
        
        ctk.CTkLabel(gm_pane, text="Linked Quests", font=ctk.CTkFont(size=14, weight="bold")).grid(row=4, column=0, sticky="w", pady=(10,5))
        self.linked_quests_frame = ctk.CTkScrollableFrame(gm_pane, label_text="")
        self.linked_quests_frame.grid(row=5, column=0, sticky="nsew", pady=(0, 10))
        
        button_frame = ctk.CTkFrame(self.sheet_content_wrapper, fg_color="transparent")
        button_frame.grid(row=2, column=0, columnspan=2, pady=20)
        ctk.CTkButton(button_frame, text="Save Changes", command=controller.save_npc_sheet).pack(side="left", padx=10)
        ctk.CTkButton(button_frame, text="Delete NPC", command=controller.delete_current_npc, fg_color="#D2691E", hover_color="#B2590E").pack(side="left", padx=10)
        self.sheet_is_built = True

    def display_sheet_data(self, npc, item_controller, npc_controller):
        if not self.sheet_is_built: return

        self.sheet_content_wrapper.pack(fill="both", expand=True)

        self.sheet_name_label.configure(text=npc.name)
        
        effective_attrs = npc.attributes.copy()
        if item_controller:
            all_items_data = {item['id']: item for item in item_controller.all_items}
            for inv_entry in npc.inventory:
                if inv_entry.get("equipped", False):
                    item_id = inv_entry["item_id"]
                    if item_id in all_items_data:
                        item_details = all_items_data[item_id]
                        for modifier in item_details.get("modifiers", []):
                            stat = modifier["stat"]
                            value = modifier["value"]
                            if stat in effective_attrs:
                                try:
                                    current_val = int(effective_attrs.get(stat, 0))
                                    effective_attrs[stat] = str(current_val + value)
                                except ValueError: pass
        
        base_max_hp_str = npc.attributes.get("Hit Points", "10")
        effective_max_hp_str = effective_attrs.get("Hit Points", base_max_hp_str)
        hp_display_text = base_max_hp_str
        if effective_max_hp_str != base_max_hp_str:
            hp_display_text = f"{effective_max_hp_str} ({base_max_hp_str})"
        self.max_hp_label.configure(text=hp_display_text)
        self.current_hp_entry.delete(0, 'end')
        self.current_hp_entry.insert(0, str(npc.current_hp))
        
        for key, entry in self.npc_sheet_entries.items():
            base_value = npc.attributes.get(key) or npc.skills.get(key) or ""
            effective_value = effective_attrs.get(key)
            display_text = base_value
            if effective_value and effective_value != base_value:
                 display_text = f"{effective_value} ({base_value})"
            entry.delete(0, 'end')
            entry.insert(0, display_text)
        
        self.sheet_notes_text.delete("1.0", "end")
        self.sheet_notes_text.insert("1.0", npc.gm_notes)
        
        quest_controller = npc_controller.app_controller.get_loaded_controller(QuestController)
        self.display_linked_quests(npc.name, quest_controller)
        self.display_inventory(npc.inventory, item_controller, npc_controller)

    def display_linked_quests(self, npc_name, quest_controller):
        for widget in self.linked_quests_frame.winfo_children():
            widget.destroy()
        if not quest_controller:
            ctk.CTkLabel(self.linked_quests_frame, text="Open 'Quests' pane\nto see links.", wraplength=150).pack(pady=10)
            return
        linked_quests = [q for q in quest_controller.get_all_quests() if npc_name in q.get('linked_npcs', [])]
        if not linked_quests:
            ctk.CTkLabel(self.linked_quests_frame, text="Not linked to any quests.").pack(pady=10)
        else:
            for quest in linked_quests:
                quest_label = ctk.CTkLabel(self.linked_quests_frame, text=f"{quest['title']} ({quest['status']})", anchor="w")
                quest_label.pack(fill="x", pady=2)

    def display_inventory(self, inventory_list, item_controller, npc_controller):
        for widget in self.inventory_list_frame.winfo_children():
            widget.destroy()
        if not item_controller:
            ctk.CTkLabel(self.inventory_list_frame, text="Open 'Items' pane\nto manage inventory.", wraplength=150).pack(pady=10)
            return
        all_items_data = {item['id']: item for item in item_controller.all_items}
        if not npc_controller: return
        for inv_entry in inventory_list:
            item_id = inv_entry["item_id"]
            if item_id in all_items_data:
                item_details = all_items_data[item_id]
                item_row = ctk.CTkFrame(self.inventory_list_frame)
                item_row.pack(fill="x", pady=2)
                equip_checkbox = ctk.CTkCheckBox(item_row, text="", width=20,
                                                 command=lambda i=inv_entry: npc_controller.toggle_item_equipped(i))
                equip_checkbox.pack(side="left", padx=5)
                if inv_entry.get("equipped", False):
                    equip_checkbox.select()
                else:
                    equip_checkbox.deselect()
                label_text = f'{item_details["name"]} (x{inv_entry["quantity"]})'
                ctk.CTkLabel(item_row, text=label_text, anchor="w").pack(side="left", expand=True, fill="x")
                ctk.CTkButton(item_row, text="X", width=25, height=25, fg_color="#D2691E", hover_color="#B2590E",
                              command=lambda i=inv_entry: npc_controller.remove_item_from_inventory(i)).pack(side="right", padx=5)

    def clear_sheet(self):
        if hasattr(self, 'sheet_content_wrapper'):
            self.sheet_content_wrapper.pack_forget()

    def update_npc_management_list(self, npcs):
        values = ["-"] + (npcs or [])
        self.npc_management_list.configure(values=values)
        self.npc_management_list.set(values[0])
        
    def update_npc_sheet_list(self, npcs):
        values = ["-"] + (npcs or [])
        self.npc_sheet_list.configure(values=values)
        self.npc_sheet_list.set(values[0])

    def highlight_selection(self):
        pass

================================================================================
--- FILE: rules/rules_controller.py ---
================================================================================

from custom_dialogs import MessageBox
from .rules_model import RulesModel

class RulesController:
    """
    Controller for the Rules feature. 
    It can act as a simple data provider for the main app,
    or as a logic handler for the standalone editor window.
    """
    def __init__(self, app_controller):
        self.app_controller = app_controller
        self.model = RulesModel()
        self.view = None # This will be set for the standalone editor

    def set_view(self, view):
        """Connects this controller to the standalone editor view."""
        self.view = view

    def save_new_rule_set(self):
        """Saves a new rule set. This is ONLY called from the standalone window."""
        if not self.view:
            print("Error: Save function called without a view.")
            return

        name = self.view.rules_name_entry.get()
        if not name:
            MessageBox.showerror("Error", "Rule set name is required.", parent=self.view)
            return
        
        attrs = [attr.strip() for attr in self.view.rules_attrs_entry.get().split(',') if attr.strip()]
        skills_raw = self.view.rules_skills_text.get("1.0", "end").strip().split('\n')
        skills = {s.split(':')[0].strip(): s.split(':')[1].strip() for s in skills_raw if ':' in s}
        formulas_raw = self.view.rules_formulas_text.get("1.0", "end").strip().split('\n')
        formulas = {f.split(':')[0].strip(): f.split(':')[1].strip() for f in formulas_raw if ':' in f}

        self.model.save_rule_set(name, attrs, skills, formulas)
        MessageBox.showinfo("Success", f"Rule set '{name}' saved.", parent=self.view)

================================================================================
--- FILE: rules/rules_editor_window.py ---
================================================================================

import customtkinter as ctk

class RulesEditorWindow(ctk.CTkToplevel):
    """A standalone, modal Toplevel window for creating and editing a rule set."""
    def __init__(self, parent):
        super().__init__(parent)
        self.controller = None

        self.title("Rule Set Editor")
        self.geometry("800x600")
        self.configure(fg_color="#2B2B2B")
        
        # --- THE FIX: Intercept the 'X' button click ---
        self.protocol("WM_DELETE_WINDOW", self._on_close)

        container = ctk.CTkFrame(self, fg_color="transparent")
        container.pack(fill="both", expand=True)
        container.grid_columnconfigure((0,1), weight=1)
        container.grid_rowconfigure(4, weight=1)
        
        # ... (The rest of the UI setup is unchanged) ...
        ctk.CTkLabel(container, text="Rule Set Editor", font=ctk.CTkFont(size=18, weight="bold")).grid(row=0, column=0, columnspan=2, padx=20, pady=20)
        ctk.CTkLabel(container, text="Rule Set Name:", anchor="w").grid(row=1, column=0, columnspan=2, padx=20, sticky="w")
        self.rules_name_entry = ctk.CTkEntry(container)
        self.rules_name_entry.grid(row=1, column=0, columnspan=2, padx=20, pady=(0,10), sticky="ew")
        ctk.CTkLabel(container, text="Attributes (comma-separated):", anchor="w").grid(row=2, column=0, columnspan=2, padx=20, sticky="w")
        self.rules_attrs_entry = ctk.CTkEntry(container)
        self.rules_attrs_entry.grid(row=2, column=0, columnspan=2, padx=20, pady=(0,10), sticky="ew")
        self.rules_attrs_entry.insert(0, "Strength, Dexterity, Hit Points")
        ctk.CTkLabel(container, text="Skills (Skill:Attribute, one per line):", anchor="w").grid(row=3, column=0, padx=(20,10), sticky="w")
        self.rules_skills_text = ctk.CTkTextbox(container)
        self.rules_skills_text.grid(row=4, column=0, padx=(20,10), pady=(0,10), sticky="nsew")
        self.rules_skills_text.insert("1.0", "Athletics:Strength\nStealth:Dexterity")
        ctk.CTkLabel(container, text="Formulas (Name:Formula, one per line):", anchor="w").grid(row=3, column=1, padx=(10,20), sticky="w")
        self.rules_formulas_text = ctk.CTkTextbox(container)
        self.rules_formulas_text.grid(row=4, column=1, padx=(10,20), pady=(0,10), sticky="nsew")
        self.rules_formulas_text.insert("1.0", "Dodge Chance:Dexterity * 2 + 10")
        self.save_button = ctk.CTkButton(container, text="Save Rule Set")
        self.save_button.grid(row=5, column=0, columnspan=2, pady=20)

        self.grab_set()

    def _on_close(self):
        """Ensures the grab is released before destroying the window."""
        self.grab_release()
        self.destroy()

    def set_controller(self, controller):
        """Connects the controller to this view."""
        self.controller = controller
        self.save_button.configure(command=self.controller.save_new_rule_set)

================================================================================
--- FILE: rules/rules_model.py ---
================================================================================

import json
import os
from utils import resource_path # Import the helper

class RulesModel:
    """Model for managing TTRPG rule sets (loading, saving, listing)."""
    def __init__(self, rules_dir_name='data/rule_sets'):
        # Use the helper to get the correct base directory
        self.rules_dir = resource_path(rules_dir_name)
        if not os.path.exists(self.rules_dir):
            os.makedirs(self.rules_dir)

    def save_rule_set(self, name, attributes, skills, formulas):
        rule_set = { 'name': name, 'attributes': attributes, 'skills': skills, 'formulas': formulas }
        filepath = os.path.join(self.rules_dir, f"{name.lower().replace(' ', '_')}.json")
        with open(filepath, 'w') as f:
            json.dump(rule_set, f, indent=4)

    def load_rule_set(self, name):
        filepath = os.path.join(self.rules_dir, f"{name.lower().replace(' ', '_')}.json")
        if not os.path.exists(filepath):
            return None
        with open(filepath, 'r') as f:
            return json.load(f)

    def get_all_rule_sets(self):
        if not os.path.exists(self.rules_dir):
            return []
        return sorted([f.replace('.json', '').replace('_', ' ').title() for f in os.listdir(self.rules_dir) if f.endswith('.json')])

================================================================================
--- FILE: character/character_controller.py ---
================================================================================

from tkinter import messagebox
from .character_model import CharacterModel
from .character_view import CharacterView, AddItemDialog
from custom_dialogs import MessageBox
from item.item_controller import ItemController
from quest.quest_controller import QuestController

class CharacterController:
    def __init__(self, app_controller, parent_frame, campaign_path):
        self.app_controller = app_controller
        self.view = CharacterView(parent_frame)
        self.campaign_path = campaign_path
        self.current_rule_set = None
        self.current_character = None
        self.view.setup_ui(self)
        
        # --- LAZY LOAD: Load data when controller is created ---
        self.app_controller._reload_character_cache()

    def get_item_controller(self):
        return self.app_controller.get_loaded_controller(ItemController)

    def get_quest_controller(self):
        return self.app_controller.get_loaded_controller(QuestController)

    def get_character_list(self):
        if self.current_rule_set:
            cache_key = f"characters_models_{self.current_rule_set['name']}"
            return self.app_controller.get_cached_data(cache_key) or []
        return []

    def handle_rule_set_load(self, rule_set):
        self.current_rule_set = rule_set
        self.view.build_dynamic_fields(rule_set)
        self.view.build_sheet_ui(rule_set, self)
        self.update_character_sheet_list()

    def update_character_sheet_list(self):
        if self.current_rule_set:
            characters = self.get_character_list()
            char_names = [char.name for char in characters]
            self.view.update_character_list(char_names)
        else:
            self.view.update_character_list([])
        self.view.clear_sheet()
        self.current_character = None

    def save_new_character(self):
        if not self.current_rule_set:
            MessageBox.showerror("Error", "No rule set loaded.", self.view.parent_frame)
            return
        name = self.view.char_name_entry.get()
        if not name:
            MessageBox.showerror("Error", "Character name is required.", self.view.parent_frame)
            return
        char = CharacterModel(self.campaign_path, name, self.current_rule_set['name'])
        for key, entry in self.view.char_creator_entries.items():
            value = entry.get() or "0"
            if key in self.current_rule_set['attributes']:
                char.set_attribute(key, value)
            elif key in self.current_rule_set['skills']:
                char.set_skill(key, value)
        char.current_hp = char.attributes.get("Hit Points", "10")
        char.save()
        MessageBox.showinfo("Success", f"Character '{name}' saved.", self.view.parent_frame)
        
        self.app_controller.on_character_or_npc_list_changed()

        self.view.char_name_entry.delete(0, 'end')
        for entry in self.view.char_creator_entries.values():
            entry.delete(0, 'end')

    def load_character_to_sheet(self, refresh=False):
        """Loads a selected character into the sheet view."""
        item_controller = self.get_item_controller()
        
        char_name = self.current_character.name if (refresh and self.current_character) else self.view.char_sheet_list.get().strip()
        if not char_name or char_name == "-":
            self.current_character = None
            self.view.clear_sheet()
            return
            
        self.current_character = CharacterModel.load(self.campaign_path, char_name)
        if not self.current_character:
            MessageBox.showerror("Error", f"Could not load character: {char_name}", self.view.parent_frame)
            return
            
        # The view will handle the case where item_controller is None
        self.view.display_sheet_data(self.current_character, item_controller, self)
        
        if not refresh:
            self.app_controller.set_dirty_flag(False)

    def save_character_sheet(self):
        if not self.current_character: return
        self.current_character.current_hp = self.view.current_hp_entry.get()
        for key, entry in self.view.char_sheet_entries.items():
            full_value = entry.get()
            if "(" in full_value and full_value.endswith(")"):
                base_value = full_value.split('(')[-1].strip(')')
            else:
                base_value = full_value
            if key in self.current_character.attributes:
                self.current_character.set_attribute(key, base_value)
            elif key in self.current_character.skills:
                self.current_character.set_skill(key, base_value)
        self.current_character.save()
        self.app_controller.set_dirty_flag(False)
        MessageBox.showinfo("Success", f"Changes to '{self.current_character.name}' saved.", self.view.parent_frame)

    def delete_current_character(self):
        if not self.current_character: return
        char_name = self.current_character.name
        if MessageBox.askyesno("Confirm Deletion", f"Are you sure you want to permanently delete {char_name}?", self.view.parent_frame):
            if CharacterModel.delete(self.campaign_path, char_name):
                MessageBox.showinfo("Deleted", f"Character '{char_name}' has been deleted.", self.view.parent_frame)
                self.current_character = None
                self.view.clear_sheet()

                self.app_controller.on_character_or_npc_list_changed()
                self.app_controller.set_dirty_flag(False)
            else:
                MessageBox.showerror("Error", f"Could not find file for character '{char_name}'.", self.view.parent_frame)

    def show_add_item_dialog(self):
        """Opens the dialog to add an item to the current character's inventory."""
        if not self.current_character: return
        item_controller = self.get_item_controller()
        # --- FIX: Keep the check here, as you can't *add* items if the pane isn't open ---
        if not item_controller:
            MessageBox.showerror("Error", "The 'Items' feature must be open in a pane to add items.", self.view.parent_frame)
            return
        
        dialog = AddItemDialog(parent=self.view.parent_frame, all_items=item_controller.all_items)
        selected_item = dialog.get_selection()
        if selected_item:
            self.add_item_to_inventory(selected_item)

    def add_item_to_inventory(self, item_to_add):
        if not self.current_character: return
        item_controller = self.get_item_controller()
        if not item_controller: return
        for inv_entry in self.current_character.inventory:
            if inv_entry["item_id"] == item_to_add["id"]:
                inv_entry["quantity"] += 1
                break
        else:
            self.current_character.inventory.append({"item_id": item_to_add["id"], "quantity": 1, "equipped": False})
        self.view.display_sheet_data(self.current_character, item_controller, self)
        self.mark_as_dirty()

    def remove_item_from_inventory(self, inv_entry_to_remove):
        if not self.current_character: return
        item_controller = self.get_item_controller()
        if not item_controller: return
        for i, inv_entry in enumerate(self.current_character.inventory):
            if inv_entry["item_id"] == inv_entry_to_remove["item_id"]:
                inv_entry["quantity"] -= 1
                if inv_entry["quantity"] <= 0:
                    self.current_character.inventory.pop(i)
                break
        self.view.display_sheet_data(self.current_character, item_controller, self)
        self.mark_as_dirty()

    def toggle_item_equipped(self, inv_entry_to_toggle):
        if not self.current_character: return
        item_controller = self.get_item_controller()
        if not item_controller: return
        for inv_entry in self.current_character.inventory:
            if inv_entry["item_id"] == inv_entry_to_toggle["item_id"]:
                inv_entry["equipped"] = not inv_entry.get("equipped", False)
                break
        self.view.display_sheet_data(self.current_character, item_controller, self)
        self.mark_as_dirty()

    def mark_as_dirty(self, event=None):
        self.app_controller.set_dirty_flag(True)

================================================================================
--- FILE: character/character_model.py ---
================================================================================

import json
from database import Database

class CharacterModel:
    def __init__(self, campaign_path, name, rule_set_name):
        self.campaign_path = campaign_path
        self.name = name
        self.rule_set_name = rule_set_name
        self.attributes = {}
        self.skills = {}
        self.inventory = []
        self.current_hp = None

    def set_attribute(self, attribute, value): self.attributes[attribute] = value
    def set_skill(self, skill, value): self.skills[skill] = value

    def to_dict(self):
        if self.current_hp is None:
            self.current_hp = self.attributes.get("Hit Points", "10")
        return {
            'name': self.name, 'rule_set': self.rule_set_name, 
            'attributes': self.attributes, 'skills': self.skills, 'inventory': self.inventory,
            'current_hp': self.current_hp
        }

    @classmethod
    def from_dict(cls, campaign_path, data):
        char = cls(campaign_path, data['name'], data['rule_set'])
        char.attributes = data.get('attributes', {})
        char.skills = data.get('skills', {})
        char.inventory = data.get('inventory', [])
        max_hp = char.attributes.get("Hit Points", "10")
        char.current_hp = data.get('current_hp', max_hp)
        return char

    def save(self):
        """Saves the character data to the database."""
        db = Database(self.campaign_path)
        db.connect()
        char_id = self.name.lower().replace(' ', '_')
        data_json = json.dumps(self.to_dict())
        db.execute(
            "INSERT OR REPLACE INTO characters (id, name, rule_set, data) VALUES (?, ?, ?, ?)",
            (char_id, self.name, self.rule_set_name, data_json)
        )
        db.close()

    @staticmethod
    def load(campaign_path, character_name):
        """Loads a single character from the database by name."""
        db = Database(campaign_path)
        db.connect()
        char_id = character_name.lower().replace(' ', '_')
        row = db.fetchone("SELECT data FROM characters WHERE id = ?", (char_id,))
        db.close()
        if row:
            data = json.loads(row['data'])
            return CharacterModel.from_dict(campaign_path, data)
        return None

    @staticmethod
    def get_all_for_ruleset(campaign_path, rule_set_name):
        """Loads all characters for a ruleset in a single query."""
        db = Database(campaign_path)
        db.connect()
        rows = db.fetchall("SELECT data FROM characters WHERE rule_set = ?", (rule_set_name,))
        db.close()
        return [CharacterModel.from_dict(campaign_path, json.loads(row['data'])) for row in rows]

    @staticmethod
    def delete(campaign_path, character_name):
        """Deletes a character from the database."""
        db = Database(campaign_path)
        db.connect()
        char_id = character_name.lower().replace(' ', '_')
        db.execute("DELETE FROM characters WHERE id = ?", (char_id,))
        db.close()
        return True

================================================================================
--- FILE: character/character_view.py ---
================================================================================

import customtkinter as ctk
from ui_extensions import AutoWidthComboBox
from quest.quest_controller import QuestController

class AddItemDialog(ctk.CTkToplevel):
    """A reusable modal dialog for adding an item from a master list."""
    def __init__(self, parent, all_items):
        super().__init__(parent)
        self.title("Add Item to Inventory")
        self.geometry("400x500")
        self.configure(fg_color="#2B2B2B")
        self.protocol("WM_DELETE_WINDOW", self._on_cancel)
        self.selected_item = None
        self.buttons = []
        ctk.CTkLabel(self, text="Select an Item to Add", font=ctk.CTkFont(size=16)).pack(pady=10)
        self.scroll_frame = ctk.CTkScrollableFrame(self)
        self.scroll_frame.pack(fill="both", expand=True, padx=10, pady=5)
        if not all_items:
            ctk.CTkLabel(self.scroll_frame, text="No items created in this campaign yet.").pack()
        else:
            for item in all_items:
                btn = ctk.CTkButton(self.scroll_frame, text=f'{item["name"]} ({item["type"]})',
                                    command=lambda i=item: self._select(i), 
                                    fg_color="transparent", anchor="w", border_width=1, border_color="gray50")
                btn.pack(fill="x", pady=2)
                self.buttons.append((btn, item))
        self.confirm_button = ctk.CTkButton(self, text="Add Selected Item", command=self._on_confirm, state="disabled")
        self.confirm_button.pack(pady=10)
        self.transient(parent)
        self.update_idletasks()
        self.grab_set()
        self.wait_window()

    def _select(self, item):
        self.selected_item = item
        self.confirm_button.configure(state="normal")
        for btn, btn_item in self.buttons:
            if btn_item["id"] == item["id"]:
                btn.configure(fg_color="#3B8ED0", border_color="#3B8ED0")
            else:
                btn.configure(fg_color="transparent", border_color="gray50")

    def _on_confirm(self):
        self.grab_release()
        self.destroy()

    def _on_cancel(self):
        self.selected_item = None
        self.grab_release()
        self.destroy()

    def get_selection(self):
        return self.selected_item

class CharacterView:
    def __init__(self, parent_frame):
        # The parent frame will manage this view's frame with grid
        parent_frame.grid_rowconfigure(0, weight=1)
        parent_frame.grid_columnconfigure(0, weight=1)
        
        self.frame = ctk.CTkTabview(parent_frame, fg_color="transparent")
        self.frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        self.creator_tab = self.frame.add("Creator")
        self.sheet_tab = self.frame.add("Sheet")
        
        self.char_creator_entries = {}
        self.char_sheet_entries = {}
        self.sheet_is_built = False

    def setup_ui(self, controller):
        self.setup_creator_ui(controller)
        self.setup_sheet_ui(controller)

    def setup_creator_ui(self, controller):
        container = ctk.CTkFrame(self.creator_tab, fg_color="transparent")
        container.pack(fill="both", expand=True)
        container.grid_columnconfigure(0, weight=1)
        container.grid_rowconfigure(2, weight=1)
        ctk.CTkLabel(container, text="Create New Character", font=ctk.CTkFont(size=18, weight="bold")).grid(row=0, column=0, padx=20, pady=20)
        name_frame = ctk.CTkFrame(container)
        name_frame.grid(row=1, column=0, pady=5, padx=20, sticky="ew")
        ctk.CTkLabel(name_frame, text="Character Name:", width=150, anchor="w").pack(side="left", padx=10, pady=5)
        self.char_name_entry = ctk.CTkEntry(name_frame)
        self.char_name_entry.pack(side="left", fill="x", expand=True, padx=(0, 10), pady=5)
        self.char_creator_fields_frame = ctk.CTkScrollableFrame(container, label_text="Stats")
        self.char_creator_fields_frame.grid(row=2, column=0, pady=10, padx=20, sticky="nsew")
        ctk.CTkButton(container, text="Save Character", height=40, command=controller.save_new_character).grid(row=3, column=0, pady=20)

    def setup_sheet_ui(self, controller):
        container = ctk.CTkFrame(self.sheet_tab, fg_color="transparent")
        container.pack(fill="both", expand=True)
        container.grid_columnconfigure(0, weight=1)
        container.grid_rowconfigure(1, weight=1)
        load_frame = ctk.CTkFrame(container)
        load_frame.grid(row=0, column=0, pady=(10, 20), padx=20, sticky="ew")
        ctk.CTkLabel(load_frame, text="Load Character:").pack(side="left", padx=(10,10))
        self.char_sheet_list = AutoWidthComboBox(load_frame, values=["-"], state="readonly")
        self.char_sheet_list.pack(side="left", padx=5, fill="x", expand=True)
        self.char_sheet_list.bind("<Button-1>", lambda event: self.char_sheet_list._open_dropdown_menu())
        ctk.CTkButton(load_frame, text="Load", command=controller.load_character_to_sheet).pack(side="left", padx=(10,10))
        self.sheet_content_frame = ctk.CTkFrame(container, fg_color="transparent")
        self.sheet_content_frame.grid(row=1, column=0, pady=10, padx=20, sticky="nsew")
        
    def build_dynamic_fields(self, rule_set):
        for widget in self.char_creator_fields_frame.winfo_children():
            widget.destroy()
        self.char_creator_entries.clear()
        container = ctk.CTkFrame(self.char_creator_fields_frame, fg_color="transparent")
        ctk.CTkLabel(container, text="Attributes", font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", pady=(10,5), padx=5)
        for attr in rule_set['attributes']:
            frame = ctk.CTkFrame(container, fg_color="transparent")
            frame.pack(fill="x", padx=5, pady=4)
            ctk.CTkLabel(frame, text=attr, width=150, anchor="w").pack(side="left")
            entry = ctk.CTkEntry(frame)
            entry.pack(side="left", fill="x", expand=True)
            self.char_creator_entries[attr] = entry
        ctk.CTkLabel(container, text="Skills", font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", pady=(10,5), padx=5)
        for skill, base_attr in rule_set['skills'].items():
            frame = ctk.CTkFrame(container, fg_color="transparent")
            frame.pack(fill="x", padx=5, pady=4)
            label = f"{skill} ({base_attr[:3]})"
            ctk.CTkLabel(frame, text=label, width=150, anchor="w").pack(side="left")
            entry = ctk.CTkEntry(frame)
            entry.pack(side="left", fill="x", expand=True)
            self.char_creator_entries[skill] = entry
        container.pack(fill="both", expand=True)

    def build_sheet_ui(self, rule_set, controller):
        self.clear_sheet()
        self.char_sheet_entries.clear()
        self.sheet_content_wrapper = ctk.CTkFrame(self.sheet_content_frame, fg_color="transparent")
        self.sheet_content_wrapper.grid_columnconfigure((0, 1), weight=1)
        self.sheet_content_wrapper.grid_rowconfigure(1, weight=1)
        self.sheet_name_label = ctk.CTkLabel(self.sheet_content_wrapper, text="", font=ctk.CTkFont(size=20, weight="bold"))
        self.sheet_name_label.grid(row=0, column=0, columnspan=2, pady=5, padx=10, sticky="w")
        
        stats_frame = ctk.CTkScrollableFrame(self.sheet_content_wrapper, label_text="Stats & Skills")
        stats_frame.grid(row=1, column=0, sticky="nsew", padx=(0, 10))
        
        hp_frame = ctk.CTkFrame(stats_frame, fg_color="gray20")
        hp_frame.pack(fill="x", padx=5, pady=5)
        hp_frame.grid_columnconfigure(1, weight=1)
        ctk.CTkLabel(hp_frame, text="Current HP:", anchor="w").grid(row=0, column=0, padx=5, pady=2)
        self.current_hp_entry = ctk.CTkEntry(hp_frame)
        self.current_hp_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.current_hp_entry.bind("<KeyRelease>", controller.mark_as_dirty)
        ctk.CTkLabel(hp_frame, text="Max HP:", anchor="w").grid(row=1, column=0, padx=5, pady=2)
        self.max_hp_label = ctk.CTkLabel(hp_frame, text="10", anchor="w")
        self.max_hp_label.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        right_column = ctk.CTkFrame(self.sheet_content_wrapper, fg_color="transparent")
        right_column.grid(row=1, column=1, sticky="nsew", padx=(10, 0))
        right_column.grid_rowconfigure(1, weight=1)
        right_column.grid_rowconfigure(3, weight=1)
        
        inv_frame = ctk.CTkFrame(right_column)
        inv_frame.grid(row=0, column=0, rowspan=2, sticky="nsew")
        inv_frame.grid_columnconfigure(0, weight=1)
        inv_frame.grid_rowconfigure(1, weight=1)
        inv_header_frame = ctk.CTkFrame(inv_frame, fg_color="transparent")
        inv_header_frame.grid(row=0, column=0, sticky="ew", pady=(0,5))
        ctk.CTkLabel(inv_header_frame, text="Inventory", font=ctk.CTkFont(size=14, weight="bold")).pack(side="left")
        ctk.CTkButton(inv_header_frame, text="Add Item", width=80, command=controller.show_add_item_dialog).pack(side="right")
        self.inventory_list_frame = ctk.CTkScrollableFrame(inv_frame)
        self.inventory_list_frame.grid(row=1, column=0, sticky="nsew")

        quest_frame = ctk.CTkFrame(right_column)
        quest_frame.grid(row=2, column=0, rowspan=2, sticky="nsew", pady=(10, 0))
        quest_frame.grid_columnconfigure(0, weight=1)
        quest_frame.grid_rowconfigure(1, weight=1)
        ctk.CTkLabel(quest_frame, text="Linked Quests", font=ctk.CTkFont(size=14, weight="bold")).grid(row=0, column=0, sticky="w", padx=10, pady=5)
        self.linked_quests_frame = ctk.CTkScrollableFrame(quest_frame, label_text="")
        self.linked_quests_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0, 10))
        
        all_stat_keys = rule_set['attributes'] + list(rule_set['skills'].keys())
        for key in all_stat_keys:
            if key == "Hit Points": continue
            frame = ctk.CTkFrame(stats_frame, fg_color="transparent")
            frame.pack(fill="x", padx=5, pady=4)
            ctk.CTkLabel(frame, text=key, width=150, anchor="w").pack(side="left")
            entry = ctk.CTkEntry(frame)
            entry.pack(side="left", fill="x", expand=True)
            self.char_sheet_entries[key] = entry
            entry.bind("<KeyRelease>", controller.mark_as_dirty)

        button_frame = ctk.CTkFrame(self.sheet_content_wrapper, fg_color="transparent")
        button_frame.grid(row=2, column=0, columnspan=2, pady=10)
        ctk.CTkButton(button_frame, text="Save Changes", command=controller.save_character_sheet).pack(side="left", padx=10)
        ctk.CTkButton(button_frame, text="Delete Character", command=controller.delete_current_character, fg_color="#D2691E", hover_color="#B2590E").pack(side="left", padx=10)
        self.sheet_is_built = True

    def display_sheet_data(self, character, item_controller, char_controller):
        if not self.sheet_is_built: return
        
        self.sheet_content_wrapper.pack(fill="both", expand=True)

        self.sheet_name_label.configure(text=character.name)
        
        effective_attrs = character.attributes.copy()
        
        # --- FIX: Check if item_controller exists before calculating stats ---
        if item_controller:
            all_items_data = {item['id']: item for item in item_controller.all_items}
            for inv_entry in character.inventory:
                if inv_entry.get("equipped", False):
                    item_id = inv_entry["item_id"]
                    if item_id in all_items_data:
                        item_details = all_items_data[item_id]
                        for modifier in item_details.get("modifiers", []):
                            stat = modifier["stat"]
                            value = modifier["value"]
                            if stat in effective_attrs:
                                try:
                                    current_val = int(effective_attrs.get(stat, 0))
                                    effective_attrs[stat] = str(current_val + value)
                                except ValueError: pass
        
        base_max_hp_str = character.attributes.get("Hit Points", "10")
        effective_max_hp_str = effective_attrs.get("Hit Points", base_max_hp_str)
        hp_display_text = base_max_hp_str
        if effective_max_hp_str != base_max_hp_str:
            hp_display_text = f"{effective_max_hp_str} ({base_max_hp_str})"
        self.max_hp_label.configure(text=hp_display_text)
        self.current_hp_entry.delete(0, 'end')
        self.current_hp_entry.insert(0, str(character.current_hp))
        
        for key, entry in self.char_sheet_entries.items():
            base_value = character.attributes.get(key) or character.skills.get(key) or ""
            effective_value = effective_attrs.get(key)
            display_text = base_value
            if effective_value and effective_value != base_value:
                 display_text = f"{effective_value} ({base_value})"
            entry.delete(0, 'end')
            entry.insert(0, display_text)
            
        quest_controller = char_controller.app_controller.get_loaded_controller(QuestController)
        self.display_linked_quests(character.name, quest_controller)
        self.display_inventory(character.inventory, item_controller, char_controller)
        
    def display_linked_quests(self, char_name, quest_controller):
        for widget in self.linked_quests_frame.winfo_children():
            widget.destroy()
            
        # --- FIX: Display a helpful message if the Quest pane isn't open ---
        if not quest_controller:
            ctk.CTkLabel(self.linked_quests_frame, text="Open 'Quests' pane\nto see links.", wraplength=150).pack(pady=10)
            return
            
        linked_quests = [q for q in quest_controller.get_all_quests() if char_name in q.get('linked_npcs', [])]
        if not linked_quests:
            ctk.CTkLabel(self.linked_quests_frame, text="Not linked to any quests.").pack(pady=10)
        else:
            for quest in linked_quests:
                quest_label = ctk.CTkLabel(self.linked_quests_frame, text=f"{quest['title']} ({quest['status']})", anchor="w")
                quest_label.pack(fill="x", pady=2)

    def display_inventory(self, inventory_list, item_controller, char_controller):
        for widget in self.inventory_list_frame.winfo_children():
            widget.destroy()
            
        # --- FIX: Display a helpful message if the Item pane isn't open ---
        if not item_controller:
            ctk.CTkLabel(self.inventory_list_frame, text="Open 'Items' pane\nto manage inventory.", wraplength=150).pack(pady=10)
            return

        all_items_data = {item['id']: item for item in item_controller.all_items}
        if not char_controller: return
        for inv_entry in inventory_list:
            item_id = inv_entry["item_id"]
            if item_id in all_items_data:
                item_details = all_items_data[item_id]
                item_row = ctk.CTkFrame(self.inventory_list_frame)
                item_row.pack(fill="x", pady=2)
                equip_checkbox = ctk.CTkCheckBox(item_row, text="", width=20,
                                                 command=lambda i=inv_entry: char_controller.toggle_item_equipped(i))
                equip_checkbox.pack(side="left", padx=5)
                if inv_entry.get("equipped", False):
                    equip_checkbox.select()
                else:
                    equip_checkbox.deselect()
                label_text = f'{item_details["name"]} (x{inv_entry["quantity"]})'
                ctk.CTkLabel(item_row, text=label_text, anchor="w").pack(side="left", expand=True, fill="x")
                ctk.CTkButton(item_row, text="X", width=25, height=25, fg_color="#D2691E", hover_color="#B2590E",
                              command=lambda i=inv_entry: char_controller.remove_item_from_inventory(i)).pack(side="right", padx=5)

    def clear_sheet(self):
        if hasattr(self, 'sheet_content_wrapper'):
            self.sheet_content_wrapper.pack_forget()

    def update_character_list(self, characters):
        values = ["-"] + (characters or [])
        self.char_sheet_list.configure(values=values)
        self.char_sheet_list.set(values[0])

================================================================================
--- FILE: item/item_controller.py ---
================================================================================

from .item_model import ItemModel
from .item_view import ItemView
from custom_dialogs import MessageBox

class ItemController:
    """Controller for the self-contained Item feature."""
    def __init__(self, app_controller, parent_frame, campaign_path):
        self.app_controller = app_controller
        self.model = ItemModel(campaign_path)
        self.view = ItemView(parent_frame)
        self.view.setup_ui(self)

        self.all_items = []
        self.selected_item = None
        self.current_rule_set = None
        
        # --- LAZY LOAD: Load data when controller is created ---
        self.load_all_items()

    def handle_rule_set_load(self, rule_set):
        """Receives the loaded rule set and tells the view to build the modifier UI."""
        self.current_rule_set = rule_set
        self.view.build_modifier_fields(rule_set, self)

    def adjust_modifier(self, stat_name, delta):
        """Called by the +/- buttons to change a stat modifier's value."""
        if stat_name in self.view.modifier_widgets:
            label = self.view.modifier_widgets[stat_name]
            current_value = int(label.cget("text"))
            new_value = current_value + delta
            label.configure(text=str(new_value))

    def load_all_items(self):
        """Loads items from the model and tells the view to display them."""
        # --- MODIFIED: No longer checks cache, it's the source of truth now ---
        self.all_items = self.model.load_all_items()
        self.app_controller.set_cached_data('items', self.all_items)

        self.all_items.sort(key=lambda x: x['name'].lower())
        self.view.display_items(self.all_items, self)
        self.clear_editor_fields()

    def select_item(self, item):
        """Handles when a user clicks on an item in the list."""
        self.selected_item = item
        self.view.populate_editor(item)
        self.view.editor_label.configure(text=f"Editing: {item['name']}")

    def _get_modifiers_from_view(self):
        """Reads all non-zero modifier values from the dynamic UI."""
        modifiers = []
        if not self.current_rule_set:
            return modifiers

        for stat_name, value_label in self.view.modifier_widgets.items():
            value = int(value_label.cget("text"))
            if value != 0:
                modifiers.append({"stat": stat_name, "value": value})
        return modifiers

    def save_new_item(self):
        """Saves a brand new item."""
        name = self.view.name_entry.get()
        desc = self.view.desc_textbox.get("1.0", "end-1c")
        item_type = self.view.type_combo.get()

        if not name:
            MessageBox.showerror("Error", "Item name is required.", parent=self.view.parent_frame)
            return

        modifiers = self._get_modifiers_from_view()
        
        new_item = self.model.create_item(name, desc, item_type, modifiers)
        self.model.save_item(new_item)
        self.load_all_items()
        MessageBox.showinfo("Success", f"Item '{name}' created.", parent=self.view.parent_frame)

    def create_item_from_data(self, item_data):
        """Creates a new item from a dictionary, used by generators."""
        new_item = self.model.create_item(
            item_data["name"],
            item_data["description"],
            item_data["type"],
            item_data["modifiers"]
        )
        self.model.save_item(new_item)
        # Note: We don't call load_all_items() here to avoid multiple UI refreshes
        # The calling function (NPC controller) will handle the final UI refresh.
        return new_item

    def save_changes(self):
        """Saves changes to an existing, selected item."""
        if not self.selected_item:
            return

        new_name = self.view.name_entry.get()
        new_desc = self.view.desc_textbox.get("1.0", "end-1c")
        new_type = self.view.type_combo.get()

        if not new_name:
            MessageBox.showerror("Error", "Item name is required.", parent=self.view.parent_frame)
            return
            
        modifiers = self._get_modifiers_from_view()
        
        item_to_update = None
        for item in self.all_items:
            if item["id"] == self.selected_item["id"]:
                item["name"] = new_name
                item["description"] = new_desc
                item["type"] = new_type
                item["modifiers"] = modifiers
                item_to_update = item
                break
        
        if item_to_update:
            self.model.save_item(item_to_update)

        self.load_all_items()
        MessageBox.showinfo("Success", f"Item '{new_name}' updated.", parent=self.view.parent_frame)

    def delete_item(self):
        """Deletes the currently selected item."""
        if not self.selected_item:
            return
            
        if MessageBox.askyesno("Confirm Deletion", f"Are you sure you want to permanently delete '{self.selected_item['name']}'?", parent=self.view.parent_frame):
            self.model.delete_item(self.selected_item["id"])
            self.load_all_items()
            MessageBox.showinfo("Deleted", "Item has been deleted.", parent=self.view.parent_frame)

    def clear_editor_fields(self):
        """Clears the selection and the editor fields."""
        self.selected_item = None
        self.view.clear_editor()

================================================================================
--- FILE: item/item_model.py ---
================================================================================

import json
import uuid
from database import Database

class ItemModel:
    """Manages the item database for a specific campaign."""
    def __init__(self, campaign_path):
        self.campaign_path = campaign_path
        self.db = Database(self.campaign_path)

    def load_all_items(self):
        """Loads the entire list of items from the database."""
        self.db.connect()
        rows = self.db.fetchall("SELECT data FROM items")
        self.db.close()
        if not rows:
            return []
        return [json.loads(row['data']) for row in rows]

    def save_item(self, item_data):
        """Saves a single item to the database."""
        self.db.connect()
        self.db.execute(
            "INSERT OR REPLACE INTO items (id, data) VALUES (?, ?)",
            (item_data['id'], json.dumps(item_data))
        )
        self.db.close()

    def delete_item(self, item_id):
        """Deletes a single item from the database."""
        self.db.connect()
        self.db.execute("DELETE FROM items WHERE id = ?", (item_id,))
        self.db.close()

    def create_item(self, name, description, item_type, modifiers):
        """Creates a new item dictionary with a unique ID."""
        return {
            "id": str(uuid.uuid4()),
            "name": name,
            "description": description,
            "type": item_type,
            "modifiers": modifiers # e.g., [{"stat": "Strength", "value": 2}]
        }

================================================================================
--- FILE: item/item_view.py ---
================================================================================

import customtkinter as ctk

class ItemView:
    """Manages the UI for the self-contained Item feature."""
    def __init__(self, parent_frame):
        self.frame = parent_frame
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_columnconfigure(1, weight=2)
        self.frame.grid_rowconfigure(0, weight=1)

        self.modifier_widgets = {}

        # Left Pane: List of existing items
        list_frame = ctk.CTkFrame(self.frame)
        list_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        list_frame.grid_rowconfigure(1, weight=1)
        ctk.CTkLabel(list_frame, text="Campaign Items", font=ctk.CTkFont(size=16, weight="bold")).grid(row=0, column=0, padx=10, pady=10)
        self.item_list_frame = ctk.CTkScrollableFrame(list_frame)
        self.item_list_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")

        # Right Pane: Editor for creating/editing an item
        editor_frame = ctk.CTkFrame(self.frame)
        editor_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        editor_frame.grid_columnconfigure(0, weight=1)
        editor_frame.grid_rowconfigure(4, weight=1)
        
        self.editor_label = ctk.CTkLabel(editor_frame, text="Create New Item", font=ctk.CTkFont(size=16, weight="bold"))
        self.editor_label.grid(row=0, column=0, pady=10, padx=10)

        ctk.CTkLabel(editor_frame, text="Item Name:", anchor="w").grid(row=1, column=0, sticky="ew", padx=10)
        self.name_entry = ctk.CTkEntry(editor_frame)
        self.name_entry.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 10), columnspan=2)

        ctk.CTkLabel(editor_frame, text="Item Type:", anchor="w").grid(row=2, column=0, sticky="ew", padx=10)
        self.type_combo = ctk.CTkComboBox(editor_frame, values=["Weapon", "Armor", "Consumable", "Quest Item", "Miscellaneous"])
        self.type_combo.grid(row=2, column=0, sticky="ew", padx=10, pady=(0, 10), columnspan=2)
        self.type_combo.set("Miscellaneous")

        ctk.CTkLabel(editor_frame, text="Description:", anchor="w").grid(row=3, column=0, sticky="ew", padx=10)
        self.desc_textbox = ctk.CTkTextbox(editor_frame, height=100)
        self.desc_textbox.grid(row=3, column=0, sticky="ew", padx=10, pady=(0, 10), columnspan=2)

        self.modifier_list_frame = ctk.CTkScrollableFrame(editor_frame, label_text="Stat Modifiers (Optional)")
        self.modifier_list_frame.grid(row=4, column=0, sticky="nsew", padx=10, pady=5)

        self.button_frame = ctk.CTkFrame(editor_frame, fg_color="transparent")
        self.button_frame.grid(row=5, column=0, sticky="ew", pady=10, padx=10)

    def setup_ui(self, controller):
        """Connects controller methods to the UI buttons."""
        self.save_new_button = ctk.CTkButton(self.button_frame, text="Save New Item", command=controller.save_new_item)
        self.save_new_button.pack(side="left", padx=5)

        self.save_changes_button = ctk.CTkButton(self.button_frame, text="Save Changes", command=controller.save_changes)
        self.delete_button = ctk.CTkButton(self.button_frame, text="Delete Item", command=controller.delete_item, fg_color="#D2691E", hover_color="#B2590E")
        self.clear_button = ctk.CTkButton(self.button_frame, text="Clear Form", command=controller.clear_editor_fields)
        self.clear_button.pack(side="right", padx=5)

    def build_modifier_fields(self, rule_set, controller):
        """Dynamically creates the stat modifier UI based on the loaded ruleset."""
        for widget in self.modifier_list_frame.winfo_children():
            widget.destroy()
        self.modifier_widgets.clear()

        all_stats = rule_set.get('attributes', []) + list(rule_set.get('skills', {}).keys())
        
        for stat_name in sorted(all_stats):
            row_frame = ctk.CTkFrame(self.modifier_list_frame, fg_color="transparent")
            row_frame.pack(fill="x", pady=2)

            ctk.CTkLabel(row_frame, text=stat_name, anchor="w").pack(side="left", expand=True, fill="x")
            
            minus_button = ctk.CTkButton(row_frame, text="-", width=30, command=lambda s=stat_name: controller.adjust_modifier(s, -1))
            minus_button.pack(side="left", padx=5)
            
            value_label = ctk.CTkLabel(row_frame, text="0", width=30, anchor="center")
            value_label.pack(side="left")
            
            plus_button = ctk.CTkButton(row_frame, text="+", width=30, command=lambda s=stat_name: controller.adjust_modifier(s, 1))
            plus_button.pack(side="left", padx=5)

            self.modifier_widgets[stat_name] = value_label

    def display_items(self, items, controller):
        """Clears and repopulates the list of items on the left."""
        for widget in self.item_list_frame.winfo_children():
            widget.destroy()
        
        for item in items:
            item_row = ctk.CTkButton(self.item_list_frame, text=item["name"], anchor="w", fg_color="transparent",
                                     command=lambda i=item: controller.select_item(i))
            item_row.pack(fill="x", pady=2)

    def populate_editor(self, item):
        """Fills the editor fields with the data of the selected item."""
        self.clear_modifiers()
        self.name_entry.delete(0, 'end')
        self.name_entry.insert(0, item["name"])
        self.type_combo.set(item["type"])
        self.desc_textbox.delete("1.0", "end")
        self.desc_textbox.insert("1.0", item["description"])
        
        for modifier in item.get("modifiers", []):
            stat = modifier["stat"]
            value = modifier["value"]
            if stat in self.modifier_widgets:
                self.modifier_widgets[stat].configure(text=str(value))

        self.save_new_button.pack_forget()
        self.save_changes_button.pack(side="left", padx=5)
        self.delete_button.pack(side="left", padx=5)

    def clear_editor(self):
        """Clears all editor fields and resets button visibility."""
        self.name_entry.delete(0, 'end')
        self.type_combo.set("Miscellaneous")
        self.desc_textbox.delete("1.0", "end")
        self.clear_modifiers()
        self.editor_label.configure(text="Create New Item")

        self.save_changes_button.pack_forget()
        self.delete_button.pack_forget()
        self.save_new_button.pack(side="left", padx=5)

    def clear_modifiers(self):
        """Resets all modifier value labels to '0'."""
        for label in self.modifier_widgets.values():
            label.configure(text="0")
